<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Text" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections.Tests/FixedStringTests.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#if !UNITY_DOTSPLAYER
using System;
using System.Globalization;
using System.Threading;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using System.Text;

namespace FixedStringTests
{

[TestFixture("en-US")]
[TestFixture("da-DK")]
internal class DecimalSeparatorCulture
{
    CultureInfo testCulture;
    CultureInfo backupCulture;

    public DecimalSeparatorCulture(string culture)
    {
        testCulture = CultureInfo.CreateSpecificCulture(culture);
    }

    [SetUp]
    public virtual void Setup()
    {
        backupCulture = Thread.CurrentThread.CurrentCulture;
        Thread.CurrentThread.CurrentCulture = testCulture;
        WordStorage.Setup();
    }

    [TearDown]
    public virtual void TearDown()
    {
        Thread.CurrentThread.CurrentCulture = backupCulture;
    }

    [Test]
    public void FixedStringFormat()
    {
        Assert.AreEqual("1 0", FixedString.Format("{0} {1}", 1, 0));
        Assert.AreEqual("0.1 1.2", FixedString.Format("{0} {1}", 0.1f, 1.2f));
        Assert.AreEqual("error 500 in line 350: bubbly", FixedString.Format("error {0} in line {1}: {2}", 500, 350, "bubbly"));
    }

    <# var SIZES = new int[]{32,64,128,512,4096};
       foreach(var BYTES in SIZES)
       {
         var ALMOST_TOO_BIG = new String('o', BYTES -2 );
         var TOO_BIG = new String('o', BYTES -1 );
         for (var PARAMS = 0; PARAMS < 10; ++PARAMS)
         {
             var FORMAT = "{0}";
             var ARGS = "arg0";
             var EXPECTED = "a";
             for (var f = 1; f <= PARAMS; ++f)
             {
                 FORMAT += " {" + f + "}";
                 ARGS += ", arg" + f;
                 EXPECTED += " " + (char)('a' + f);
             }
#>

    [Test]
    public void FixedString<#=BYTES #>FormatExtension<#=PARAMS+1#>Params()
    {
        FixedString<#=BYTES #> aa = default;
        FixedString128 format = "<#=FORMAT#>";
<#
             for (var PARAM = 0; PARAM <= PARAMS; ++PARAM)
             {
                 WriteLine("        FixedString32 arg{0} = \"{1}\";", PARAM, (char)('a' + PARAM));
             }
#>
        aa.Format(format, <#=ARGS#>);
        Assert.AreEqual("<#=EXPECTED#>", aa);
    }

<#
         }
#>

    [TestCase("Antidisestablishmentarianism")]
    [TestCase("‚Å£üåπüåªüå∑üåøüåµüåæ‚Å£")]
    public void FixedString<#=BYTES#>CopyFromBytesWorks(String a)
    {
        FixedString<#=BYTES#> aa = default;
        var utf8 = Encoding.UTF8.GetBytes(a);
        unsafe
        {
            fixed(byte *b = utf8)
                aa.CopyFrom(b, (ushort)utf8.Length);
        }
        Assert.AreEqual(a, aa.ToString());
    }

    [TestCase("<#=ALMOST_TOO_BIG#>", CopyError.None)]
    [TestCase("<#=TOO_BIG#>", CopyError.Truncation)]
    public void FixedString<#=BYTES#>AtMaximumSizeWorks(String a, CopyError expectedError)
    {
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>();
        var error = aa.CopyFrom(a);
        Assert.AreEqual(expectedError, error);
    }

    [TestCase("red", 0, 0, ParseError.Syntax)]
    [TestCase("0", 1, 0, ParseError.None)]
    [TestCase("-1", 2, -1, ParseError.None)]
    [TestCase("-0", 2, 0, ParseError.None)]
    [TestCase("100", 3, 100, ParseError.None)]
    [TestCase("-100", 4, -100, ParseError.None)]
    [TestCase("100.50", 3, 100, ParseError.None)]
    [TestCase("-100ab", 4, -100, ParseError.None)]
    [TestCase("2147483647", 10, 2147483647, ParseError.None)]
    [TestCase("-2147483648", 11, -2147483648, ParseError.None)]
    [TestCase("2147483648", 10, 0, ParseError.Overflow)]
    [TestCase("-2147483649", 11, 0, ParseError.Overflow)]
    public void FixedString<#=BYTES#>ParseIntWorks(String a, int expectedOffset, int expectedOutput, ParseError expectedResult)
    {
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>(a);
        int offset = 0;
        int output = 0;
        var result = aa.Parse(ref offset, ref output);
        Assert.AreEqual(expectedResult, result);
        Assert.AreEqual(expectedOffset, offset);
        if (result == ParseError.None)
        {
            Assert.AreEqual(expectedOutput, output);
        }
    }

    [TestCase("red", 0, ParseError.Syntax)]
    [TestCase("0", 1,  ParseError.None)]
    [TestCase("-1", 2, ParseError.None)]
    [TestCase("-0", 2, ParseError.None)]
    [TestCase("100", 3, ParseError.None)]
    [TestCase("-100", 4, ParseError.None)]
    [TestCase("100.50", 6, ParseError.None)]
    [TestCase("2147483648", 10, ParseError.None)]
    [TestCase("-2147483649", 11, ParseError.None)]
    [TestCase("-10E10", 6, ParseError.None)]
    [TestCase("-10E-10", 7, ParseError.None)]
    [TestCase("-10E+10", 7, ParseError.None)]
    [TestCase("10E-40", 5, ParseError.Underflow)]
    [TestCase("10E+40", 5, ParseError.Overflow)]
    [TestCase("-Infinity", 9, ParseError.None)]
    [TestCase("Infinity", 8, ParseError.None)]
    [TestCase("1000001",       7, ParseError.None)]
    [TestCase("10000001",      8, ParseError.None)]
    [TestCase("100000001",     9, ParseError.None)]
    [TestCase("1000000001",   10, ParseError.None)]
    [TestCase("10000000001",  11, ParseError.None)]
    [TestCase("100000000001", 12, ParseError.None)]
    public void FixedString<#=BYTES#>ParseFloat(String unlocalizedString, int expectedOffset, ParseError expectedResult)
    {
        var localizedDecimalSeparator = Convert.ToChar(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator);
        var localizedString = unlocalizedString.Replace('.', localizedDecimalSeparator);
        float expectedOutput = 0;
        try { expectedOutput = Single.Parse(localizedString); } catch {}
        FixedString<#=BYTES#> nativeLocalizedString = new FixedString<#=BYTES#>(localizedString);
        int offset = 0;
        float output = 0;
        var result = nativeLocalizedString.Parse(ref offset, ref output, localizedDecimalSeparator);
        Assert.AreEqual(expectedResult, result);
        Assert.AreEqual(expectedOffset, offset);
        if (result == ParseError.None)
        {
            Assert.AreEqual(expectedOutput, output);
        }
    }

    [TestCase(-2147483648)]
    [TestCase(-100)]
    [TestCase(-1)]
    [TestCase(0)]
    [TestCase(1)]
    [TestCase(100)]
    [TestCase(2147483647)]
    public void FixedString<#=BYTES#>FormatInt(int input)
    {
        var expectedOutput = input.ToString();
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>();
        var result = aa.Format(input);
        Assert.AreEqual(FormatError.None, result);
        var actualOutput = aa.ToString();
        Assert.AreEqual(expectedOutput, actualOutput);
    }

    [TestCase(-9223372036854775808L)]
    [TestCase(-100L)]
    [TestCase(-1L)]
    [TestCase(0L)]
    [TestCase(1L)]
    [TestCase(100L)]
    [TestCase(9223372036854775807L)]
    public void FixedString<#=BYTES#>FormatLong(long input)
    {
        var expectedOutput = input.ToString();
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>();
        var result = aa.Format(input);
        Assert.AreEqual(FormatError.None, result);
        var actualOutput = aa.ToString();
        Assert.AreEqual(expectedOutput, actualOutput);
    }

    [TestCase(Single.NaN, FormatError.None)]
    [TestCase(Single.PositiveInfinity, FormatError.None)]
    [TestCase(Single.NegativeInfinity, FormatError.None)]
    [TestCase(0.0f, FormatError.None)]
    [TestCase(-1.0f, FormatError.None)]
    [TestCase(100.0f, FormatError.None)]
    [TestCase(-100.0f, FormatError.None)]
    [TestCase(100.5f, FormatError.None)]
    [TestCase(0.001005f, FormatError.None)]
    [TestCase(0.0001f, FormatError.None)]
    [TestCase(0.00001f, FormatError.None)]
    [TestCase(0.000001f, FormatError.None)]
    [TestCase(-1E10f, FormatError.None)]
    [TestCase(-1E-10f, FormatError.None)]
    [TestCase(3.402823E+38f, FormatError.None)]
    public void FixedString<#=BYTES#>FormatFloat(float input, FormatError expectedResult)
    {
        var localizedDecimalSeparator = Convert.ToChar(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator);
        var expectedOutput = input.ToString();
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>();
        var result = aa.Format(input, localizedDecimalSeparator);
        Assert.AreEqual(expectedResult, result);
        if (result == FormatError.None)
        {
            var actualOutput = aa.ToString();
            Assert.AreEqual(expectedOutput, actualOutput);
        }
    }

    [TestCase(-2147483648)]
    [TestCase(-100)]
    [TestCase(-1)]
    [TestCase(0)]
    [TestCase(1)]
    [TestCase(100)]
    [TestCase(2147483647)]
    public void FixedString<#=BYTES#>AppendInt(int input)
    {
        var expectedOutput = "foo" + input.ToString();
        FixedString<#=BYTES#> aa = "foo";
        var result = aa.Append(input);
        Assert.AreEqual(FormatError.None, result);
        var actualOutput = aa.ToString();
        Assert.AreEqual(expectedOutput, actualOutput);
    }

    [TestCase(-9223372036854775808L)]
    [TestCase(-100L)]
    [TestCase(-1L)]
    [TestCase(0L)]
    [TestCase(1L)]
    [TestCase(100L)]
    [TestCase(9223372036854775807L)]
    public void FixedString<#=BYTES#>AppendLong(long input)
    {
        var expectedOutput = "foo" + input.ToString();
        FixedString<#=BYTES#> aa = "foo";
        var result = aa.Append(input);
        Assert.AreEqual(FormatError.None, result);
        var actualOutput = aa.ToString();
        Assert.AreEqual(expectedOutput, actualOutput);
    }

    [TestCase(Single.NaN, FormatError.None)]
    [TestCase(Single.PositiveInfinity, FormatError.None)]
    [TestCase(Single.NegativeInfinity, FormatError.None)]
    [TestCase(0.0f, FormatError.None)]
    [TestCase(-1.0f, FormatError.None)]
    [TestCase(100.0f, FormatError.None)]
    [TestCase(-100.0f, FormatError.None)]
    [TestCase(100.5f, FormatError.None)]
    [TestCase(0.001005f, FormatError.None)]
    [TestCase(0.0001f, FormatError.None)]
    [TestCase(0.00001f, FormatError.None)]
    [TestCase(0.000001f, FormatError.None)]
    [TestCase(-1E10f, FormatError.None)]
    [TestCase(-1E-10f, FormatError.None)]
    public void FixedString<#=BYTES#>AppendFloat(float input, FormatError expectedResult)
    {
        var localizedDecimalSeparator = Convert.ToChar(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator);
        var expectedOutput = "foo" + input.ToString();
        FixedString<#=BYTES#> aa = "foo";
        var result = aa.Append(input, localizedDecimalSeparator);
        Assert.AreEqual(expectedResult, result);
        if (result == FormatError.None)
        {
            var actualOutput = aa.ToString();
            Assert.AreEqual(expectedOutput, actualOutput);
        }
    }

    [Test]
    public void FixedString<#=BYTES#>FormatNegativeZero()
    {
        float input = -0.0f;
        var expectedOutput = input.ToString();
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>();
        var result = aa.Format(input);
        Assert.AreEqual(FormatError.None, result);
        var actualOutput = aa.ToString();
        Assert.AreEqual(expectedOutput, actualOutput);
    }

    [TestCase("en-US")]
    [TestCase("da-DK")]
    public void FixedString<#=BYTES#>ParseFloatLocale(String locale)
    {
        var original = CultureInfo.CurrentCulture;
        try
        {
            Thread.CurrentThread.CurrentCulture = new CultureInfo(locale);
            var localizedDecimalSeparator = Convert.ToChar(Thread.CurrentThread.CurrentCulture.NumberFormat.NumberDecimalSeparator);
            float value = 1.5f;
            FixedString<#=BYTES#> native = new FixedString<#=BYTES#>();
            native.Format(value, localizedDecimalSeparator);
            var nativeResult = native.ToString();
            var managedResult = value.ToString();
            Assert.AreEqual(managedResult, nativeResult);
        }
        finally
        {
            Thread.CurrentThread.CurrentCulture = original;
        }
    }

    [Test]
    public void FixedString<#=BYTES#>ParseFloatNan()
    {
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>("NaN");
        int offset = 0;
        float output = 0;
        var result = aa.Parse(ref offset, ref output);
        Assert.AreEqual(ParseError.None, result);
        Assert.IsTrue(Single.IsNaN(output));
    }

    [TestCase("red")]
    [TestCase("Á¥ÖËâ≤", TestName="{m}(Chinese-Red)")]
    [TestCase("George Washington")]
    [TestCase("Êùë‰∏äÊò•Ê®π", TestName="{m}(HarukiMurakami)")]
    public void FixedString<#=BYTES#>ToStringWorks(String a)
    {
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>(a);
        Assert.AreEqual(aa.ToString(), a);
    }

    [TestCase("monkey", "monkey")]
    [TestCase("yellow","green")]
    [TestCase("violet","Á¥ÖËâ≤", TestName="{m}(Violet-Chinese-Red")]
    [TestCase("ÁªøËâ≤","ËìùËâ≤", TestName="{m}(Chinese-Green-Blue")]
    [TestCase("ÈùõËìùËâ≤","Á¥´ÁΩóÂÖ∞Ëâ≤", TestName="{m}(Chinese-Indigo-Violet")]
    [TestCase("James Monroe","John Quincy Adams")]
    [TestCase("Andrew Jackson","Êùë‰∏äÊò•Ê®π", TestName="{m}(AndrewJackson-HarukiMurakami")]
    [TestCase("‰∏âÂ≥∂ Áî±Á¥ÄÂ§´","ÂêâÊú¨„Å∞„Å™„Å™", TestName="{m}(MishimaYukio-YoshimotoBanana")]
    public void FixedString<#=BYTES#>EqualsWorks(String a, String b)
    {
        FixedString<#=BYTES#> aa = new FixedString<#=BYTES#>(a);
        FixedString<#=BYTES#> bb = new FixedString<#=BYTES#>(b);
        Assert.AreEqual(aa.Equals(bb), a.Equals(b));
    }

    [Test]
    public void FixedString<#=BYTES#>ForEach()
    {
        FixedString<#=BYTES#> actual = "AüåïZüåë";
        FixedListInt32 expected = default;
        expected.Add('A');
        expected.Add(0x1F315);
        expected.Add('Z');
        expected.Add(0x1F311);
        int index = 0;
        foreach(var rune in actual)
        {
            Assert.AreEqual(expected[index], rune.value);
            ++index;
        }
    }

    [Test]
    public void FixedString<#=BYTES#>RuneConstructor()
    {
        Assert.AreEqual("aaaaa", new FixedString<#=BYTES#>(new Unicode.Rune{value='a'}, 5));
    }

    [Test]
    public void FixedString<#=BYTES#>IndexOf()
    {
        FixedString<#=BYTES#> a = "bookkeeper bookkeeper";
        FixedString<#=BYTES#> b = "ookkee";
        Assert.AreEqual(1, a.IndexOf(b));
        Assert.AreEqual(-1, b.IndexOf(a));
    }

    [Test]
    public void FixedString<#=BYTES#>LastIndexOf()
    {
        FixedString<#=BYTES#> a = "bookkeeper bookkeeper";
        FixedString<#=BYTES#> b = "ookkee";
        Assert.AreEqual(12, a.LastIndexOf(b));
        Assert.AreEqual(-1, b.LastIndexOf(a));
    }

    [Test]
    public void FixedString<#=BYTES#>Contains()
    {
        FixedString<#=BYTES#> a = "bookkeeper";
        FixedString<#=BYTES#> b = "ookkee";
        Assert.AreEqual(true, a.Contains(b));
    }

    [Test]
    public void FixedString<#=BYTES#>Comparisons()
    {
        FixedString<#=BYTES#> a = "apple";
        FixedString<#=BYTES#> b = "banana";
        Assert.AreEqual(false, a == b);
        Assert.AreEqual(true, a != b);
    }

    [Test]
    public void FixedString<#=BYTES#>ToFixedList()
    {
        FixedString<#=BYTES#> a = "0123";
        ref var b = ref a.AsFixedList;
        Assert.AreEqual(4, b.Length);
        Assert.AreEqual('0', b[0]);
        Assert.AreEqual('1', b[1]);
        Assert.AreEqual('2', b[2]);
        Assert.AreEqual('3', b[3]);
        b.Add((byte)'4');
        Assert.AreEqual("01234", a);
    }

    [Test]
    public void FixedString<#=BYTES#>SizeOf()
    {
        Assert.AreEqual(UnsafeUtility.SizeOf<FixedString<#=BYTES#>>(), <#=BYTES#>);
    }

<#
    var layoutString = new string[] {
        "red",
        "Á¥ÖËâ≤",
        "—Ü—Ä–≤–µ–Ω–∞",
        "George Washington",
        "Êùë‰∏äÊò•Ê®π",
        "üåïüåñüåóüåòüåëüåíüåìüåî",
        "ùíûùíØùíÆùíüùí≥ùí©ùí´ùí¢",
        "Î°úÎßàÎäî ÌïòÎ£®ÏïÑÏπ®Ïóê Ïù¥Î£®Ïñ¥ÏßÑ Í≤ÉÏù¥ ÏïÑÎãàÎã§",
        "–õ–∞–∫–æ —Ç–∏ —ò–µ –ø–ª–∏—Ç–∫—É –≤–æ–¥—É –∑–∞–º—É—Ç–∏—Ç–∏ –∏ –±—É–¥–∞–ª—É –Ω–∞—ô—É—Ç–∏—Ç–∏",
        "“Æ–Ω—ç–Ω “Ø–≥ —Ö—ç–ª—Å—ç–Ω —Ö“Ø–Ω–¥ –Ω–æ—ë–¥ ”©—Å—Ç—ç–π, “Ø—Ö—ç—Ä —É–Ω–∞—Å–∞–Ω —Ö“Ø–Ω–¥ –Ω–æ—Ö–æ–¥ ”©—Å—Ç—ç–π.",
        "‡§® ‡§Ö‡§≠‡§ø‡§∂‡•á‡§ï‡•ã ‡§® ‡§∏‡§Ç‡§∏‡•ç‡§ï‡§æ‡§∞‡§É ‡§∏‡§ø‡§Æ‡•ç‡§π‡§∏‡•ç‡§Ø ‡§ï‡•É‡§Ø‡§§‡•á ‡§µ‡§®‡•á‡§µ‡§ø‡§ï‡•ç‡§∞‡§Æ‡§æ‡§∞‡•ç‡§ú‡§ø‡§§‡§∏‡§§‡•ç‡§µ‡§∏‡•ç‡§Ø ‡§∏‡•ç‡§µ‡§Ø‡§Æ‡•á‡§µ ‡§Æ‡•É‡§ó‡•á‡§®‡•ç‡§¶‡•ç‡§∞‡§§‡§æ"
    };
    var layoutName = new string[] {
        "red",
        "{m}(Chinese-Red)",
        "{m}(Serbian-Red)",
        "George Washington",
        "{m}(HarukiMurakami)",
        "{m}(MoonPhases)",
        "{m}(Cursive)",
        "{m}(Korean - Rome was not made overnight)",
        "{m}(Serbian-Proverb)",
        "{m}(Mongolian-Proverb1)",
        "{m}(Hindi-Proverb3)"
    };
    for(var i = 0; i < layoutString.Length; ++i)
    {
        var utf8 = Encoding.UTF8;
        byte[] utfBytes = utf8.GetBytes(layoutString[i]);
        byte[] expected = new byte[utfBytes.Length + 2];
        expected[0] = (byte)((utfBytes.Length >> 0) & 0xFF);
        expected[1] = (byte)((utfBytes.Length >> 8) & 0xFF);
        Array.Copy(utfBytes, 0, expected, 2, utfBytes.Length);
        if(expected.Length <= BYTES)
        {
            var bytes = String.Join(", ", expected);
        #>
    [TestCase("<#=layoutString[i]#>", new byte[]{<#=bytes#>}, TestName="<#=layoutName[i]#>")]
<#
        }
    }
#>        unsafe public void FixedString<#=BYTES#>Layout(String a, byte[] expected)
    {
        fixed(byte* expectedBytes = expected)
        {
            FixedString<#=BYTES#> actual = a;
            byte* actualBytes = (byte*)&actual;
            Assert.AreEqual(0, UnsafeUtility.MemCmp(expectedBytes, actualBytes, expected.Length));
        }
    }

<# foreach(var OTHERBYTES in SIZES)
{
 if(OTHERBYTES != BYTES)
 { #>

    [TestCase("red")]
    [TestCase("Á¥ÖËâ≤", TestName="{m}(Chinese-Red)")]
    [TestCase("George Washington")]
    [TestCase("Êùë‰∏äÊò•Ê®π", TestName="{m}(HarukiMurakami)")]
    public void FixedString<#=BYTES#>ToFixedString<#=OTHERBYTES#>Works(String a)
    {
        var b = new FixedString<#=BYTES#>(a);
        var c = new FixedString<#=OTHERBYTES#>(b);
        String d = c.ToString();
        Assert.AreEqual(a, d);
    }
<# }
} } #>

}

}
#endif
