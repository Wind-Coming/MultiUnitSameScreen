//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections.Tests/FixedListTests.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.Threading;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

internal class FixedListTests
{
    struct NonComparableStruct
    {
        public int a;
    }

    [Test]
    public void FixedList32DebugView()
    {
        var list = new FixedList32<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList32DebugView<NonComparableStruct>(list).Items);

        var reference = new[]
        {
            new NonComparableStruct { a = 123 },
            new NonComparableStruct { a = 234 },
            new NonComparableStruct { a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList32DebugView<NonComparableStruct>(list).Items);
    }

    [Test]
    public void FixedList64DebugView()
    {
        var list = new FixedList64<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList64DebugView<NonComparableStruct>(list).Items);

        var reference = new[]
        {
            new NonComparableStruct { a = 123 },
            new NonComparableStruct { a = 234 },
            new NonComparableStruct { a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList64DebugView<NonComparableStruct>(list).Items);
    }

    [Test]
    public void FixedList128DebugView()
    {
        var list = new FixedList128<NonComparableStruct>();
        CollectionAssert.IsEmpty(new FixedList128DebugView<NonComparableStruct>(list).Items);

        var reference = new[]
        {
            new NonComparableStruct { a = 123 },
            new NonComparableStruct { a = 234 },
            new NonComparableStruct { a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new FixedList128DebugView<NonComparableStruct>(list).Items);
    }

    [Test]
    public void FixedList32byteGenericHasExpectedLayout()
    {
        var actual = new FixedList32<byte>();
        for (var i = 0; i < 30; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((30 >> 0) & 0xFF);
            e[1] = (byte)((30 >> 8) & 0xFF);
            for (var i = 0; i < 30; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32byteGenericHasExpectedCapacity()
    {
        var list = new FixedList32<byte>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedList32byteGenericInsertRange()
    {
        var list = new FixedList32<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemoveRange()
    {
        var list = new FixedList32<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericInsert()
    {
        var list = new FixedList32<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericRemove()
    {
        var list = new FixedList32<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32byteGenericSort()
    {
        var list = new FixedList32<byte>();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericHasExpectedLayout()
    {
        var actual = new FixedList64<byte>();
        for (var i = 0; i < 62; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((62 >> 0) & 0xFF);
            e[1] = (byte)((62 >> 8) & 0xFF);
            for (var i = 0; i < 62; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64byteGenericHasExpectedCapacity()
    {
        var list = new FixedList64<byte>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedList64byteGenericInsertRange()
    {
        var list = new FixedList64<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemoveRange()
    {
        var list = new FixedList64<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericInsert()
    {
        var list = new FixedList64<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericRemove()
    {
        var list = new FixedList64<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64byteGenericSort()
    {
        var list = new FixedList64<byte>();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericHasExpectedLayout()
    {
        var actual = new FixedList128<byte>();
        for (var i = 0; i < 126; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((126 >> 0) & 0xFF);
            e[1] = (byte)((126 >> 8) & 0xFF);
            for (var i = 0; i < 126; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128byteGenericHasExpectedCapacity()
    {
        var list = new FixedList128<byte>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedList128byteGenericInsertRange()
    {
        var list = new FixedList128<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemoveRange()
    {
        var list = new FixedList128<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericInsert()
    {
        var list = new FixedList128<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericRemove()
    {
        var list = new FixedList128<byte>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128byteGenericSort()
    {
        var list = new FixedList128<byte>();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte32HasExpectedLayout()
    {
        var actual = new FixedListByte32();
        for (var i = 0; i < 30; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((30 >> 0) & 0xFF);
            e[1] = (byte)((30 >> 8) & 0xFF);
            for (var i = 0; i < 30; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListByte32HasExpectedCapacity()
    {
        var list = new FixedListByte32();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedListByte32InsertRange()
    {
        var list = new FixedListByte32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte32 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListByte32RemoveAt()
    {
        var list = new FixedListByte32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32RemoveRange()
    {
        var list = new FixedListByte32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32RemoveAtSwapBack()
    {
        var list = new FixedListByte32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte32RemoveRangeSwapBack()
    {
        var list = new FixedListByte32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte32Insert()
    {
        var list = new FixedListByte32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte32Sort()
    {
        var list = new FixedListByte32();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte32ToFixedListByte64()
    {
        var a = new FixedListByte32();
        for (var i = 0; i < 30; ++i)
            a.Add((byte)i);
        var b = new FixedListByte64(a);
        for (var i = 0; i < 30; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }

    [Test]
    public void FixedListByte32ToFixedListByte128()
    {
        var a = new FixedListByte32();
        for (var i = 0; i < 30; ++i)
            a.Add((byte)i);
        var b = new FixedListByte128(a);
        for (var i = 0; i < 30; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }

    [Test]
    public void FixedListByte64HasExpectedLayout()
    {
        var actual = new FixedListByte64();
        for (var i = 0; i < 62; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((62 >> 0) & 0xFF);
            e[1] = (byte)((62 >> 8) & 0xFF);
            for (var i = 0; i < 62; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListByte64HasExpectedCapacity()
    {
        var list = new FixedListByte64();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedListByte64InsertRange()
    {
        var list = new FixedListByte64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte64 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListByte64RemoveAt()
    {
        var list = new FixedListByte64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64RemoveRange()
    {
        var list = new FixedListByte64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64RemoveAtSwapBack()
    {
        var list = new FixedListByte64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte64RemoveRangeSwapBack()
    {
        var list = new FixedListByte64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte64Insert()
    {
        var list = new FixedListByte64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte64Sort()
    {
        var list = new FixedListByte64();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte64ToFixedListByte32()
    {
        var a = new FixedListByte64();
        for (var i = 0; i < 62; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListByte32(a); });
    }

    [Test]
    public void FixedListByte64ToFixedListByte128()
    {
        var a = new FixedListByte64();
        for (var i = 0; i < 62; ++i)
            a.Add((byte)i);
        var b = new FixedListByte128(a);
        for (var i = 0; i < 62; ++i)
            Assert.AreEqual((byte)i, b[i]);
    }

    [Test]
    public void FixedListByte128HasExpectedLayout()
    {
        var actual = new FixedListByte128();
        for (var i = 0; i < 126; ++i)
            actual.Add((byte)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((126 >> 0) & 0xFF);
            e[1] = (byte)((126 >> 8) & 0xFF);
            for (var i = 0; i < 126; ++i)
            {
                var s = (byte)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<byte>() + sizeof(byte) * i, &s, sizeof(byte));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListByte128HasExpectedCapacity()
    {
        var list = new FixedListByte128();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((byte)expectedCapacity); });
    }

    [Test]
    public void FixedListByte128InsertRange()
    {
        var list = new FixedListByte128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListByte128 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListByte128RemoveAt()
    {
        var list = new FixedListByte128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128RemoveRange()
    {
        var list = new FixedListByte128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128RemoveAtSwapBack()
    {
        var list = new FixedListByte128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListByte128RemoveRangeSwapBack()
    {
        var list = new FixedListByte128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListByte128Insert()
    {
        var list = new FixedListByte128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte128Sort()
    {
        var list = new FixedListByte128();
        for (var i = 0; i < 5; ++i)
            list.Add((byte)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListByte128ToFixedListByte32()
    {
        var a = new FixedListByte128();
        for (var i = 0; i < 126; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListByte32(a); });
    }

    [Test]
    public void FixedListByte128ToFixedListByte64()
    {
        var a = new FixedListByte128();
        for (var i = 0; i < 126; ++i)
            a.Add((byte)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListByte64(a); });
    }

    [Test]
    public void FixedList32intGenericHasExpectedLayout()
    {
        var actual = new FixedList32<int>();
        for (var i = 0; i < 7; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for (var i = 0; i < 7; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32intGenericHasExpectedCapacity()
    {
        var list = new FixedList32<int>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedList32intGenericInsertRange()
    {
        var list = new FixedList32<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemoveRange()
    {
        var list = new FixedList32<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericInsert()
    {
        var list = new FixedList32<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericRemove()
    {
        var list = new FixedList32<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32intGenericSort()
    {
        var list = new FixedList32<int>();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericHasExpectedLayout()
    {
        var actual = new FixedList64<int>();
        for (var i = 0; i < 15; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for (var i = 0; i < 15; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64intGenericHasExpectedCapacity()
    {
        var list = new FixedList64<int>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedList64intGenericInsertRange()
    {
        var list = new FixedList64<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemoveRange()
    {
        var list = new FixedList64<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericInsert()
    {
        var list = new FixedList64<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericRemove()
    {
        var list = new FixedList64<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64intGenericSort()
    {
        var list = new FixedList64<int>();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericHasExpectedLayout()
    {
        var actual = new FixedList128<int>();
        for (var i = 0; i < 31; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for (var i = 0; i < 31; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128intGenericHasExpectedCapacity()
    {
        var list = new FixedList128<int>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedList128intGenericInsertRange()
    {
        var list = new FixedList128<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemoveRange()
    {
        var list = new FixedList128<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericInsert()
    {
        var list = new FixedList128<int>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericRemove()
    {
        var list = new FixedList128<int>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128intGenericSort()
    {
        var list = new FixedList128<int>();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt32HasExpectedLayout()
    {
        var actual = new FixedListInt32();
        for (var i = 0; i < 7; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for (var i = 0; i < 7; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListInt32HasExpectedCapacity()
    {
        var list = new FixedListInt32();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedListInt32InsertRange()
    {
        var list = new FixedListInt32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt32 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListInt32RemoveAt()
    {
        var list = new FixedListInt32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32RemoveRange()
    {
        var list = new FixedListInt32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32RemoveAtSwapBack()
    {
        var list = new FixedListInt32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt32RemoveRangeSwapBack()
    {
        var list = new FixedListInt32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt32Insert()
    {
        var list = new FixedListInt32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt32Sort()
    {
        var list = new FixedListInt32();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt32ToFixedListInt64()
    {
        var a = new FixedListInt32();
        for (var i = 0; i < 7; ++i)
            a.Add((int)i);
        var b = new FixedListInt64(a);
        for (var i = 0; i < 7; ++i)
            Assert.AreEqual((int)i, b[i]);
    }

    [Test]
    public void FixedListInt32ToFixedListInt128()
    {
        var a = new FixedListInt32();
        for (var i = 0; i < 7; ++i)
            a.Add((int)i);
        var b = new FixedListInt128(a);
        for (var i = 0; i < 7; ++i)
            Assert.AreEqual((int)i, b[i]);
    }

    [Test]
    public void FixedListInt64HasExpectedLayout()
    {
        var actual = new FixedListInt64();
        for (var i = 0; i < 15; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for (var i = 0; i < 15; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListInt64HasExpectedCapacity()
    {
        var list = new FixedListInt64();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedListInt64InsertRange()
    {
        var list = new FixedListInt64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt64 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListInt64RemoveAt()
    {
        var list = new FixedListInt64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64RemoveRange()
    {
        var list = new FixedListInt64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64RemoveAtSwapBack()
    {
        var list = new FixedListInt64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt64RemoveRangeSwapBack()
    {
        var list = new FixedListInt64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt64Insert()
    {
        var list = new FixedListInt64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt64Sort()
    {
        var list = new FixedListInt64();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt64ToFixedListInt32()
    {
        var a = new FixedListInt64();
        for (var i = 0; i < 15; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListInt32(a); });
    }

    [Test]
    public void FixedListInt64ToFixedListInt128()
    {
        var a = new FixedListInt64();
        for (var i = 0; i < 15; ++i)
            a.Add((int)i);
        var b = new FixedListInt128(a);
        for (var i = 0; i < 15; ++i)
            Assert.AreEqual((int)i, b[i]);
    }

    [Test]
    public void FixedListInt128HasExpectedLayout()
    {
        var actual = new FixedListInt128();
        for (var i = 0; i < 31; ++i)
            actual.Add((int)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for (var i = 0; i < 31; ++i)
            {
                var s = (int)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<int>() + sizeof(int) * i, &s, sizeof(int));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListInt128HasExpectedCapacity()
    {
        var list = new FixedListInt128();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((int)expectedCapacity); });
    }

    [Test]
    public void FixedListInt128InsertRange()
    {
        var list = new FixedListInt128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListInt128 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListInt128RemoveAt()
    {
        var list = new FixedListInt128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128RemoveRange()
    {
        var list = new FixedListInt128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128RemoveAtSwapBack()
    {
        var list = new FixedListInt128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListInt128RemoveRangeSwapBack()
    {
        var list = new FixedListInt128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListInt128Insert()
    {
        var list = new FixedListInt128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt128Sort()
    {
        var list = new FixedListInt128();
        for (var i = 0; i < 5; ++i)
            list.Add((int)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListInt128ToFixedListInt32()
    {
        var a = new FixedListInt128();
        for (var i = 0; i < 31; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListInt32(a); });
    }

    [Test]
    public void FixedListInt128ToFixedListInt64()
    {
        var a = new FixedListInt128();
        for (var i = 0; i < 31; ++i)
            a.Add((int)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListInt64(a); });
    }

    [Test]
    public void FixedList32floatGenericHasExpectedLayout()
    {
        var actual = new FixedList32<float>();
        for (var i = 0; i < 7; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for (var i = 0; i < 7; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedList32floatGenericHasExpectedCapacity()
    {
        var list = new FixedList32<float>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedList32floatGenericInsertRange()
    {
        var list = new FixedList32<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemoveRange()
    {
        var list = new FixedList32<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericInsert()
    {
        var list = new FixedList32<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericRemove()
    {
        var list = new FixedList32<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList32floatGenericSort()
    {
        var list = new FixedList32<float>();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericHasExpectedLayout()
    {
        var actual = new FixedList64<float>();
        for (var i = 0; i < 15; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for (var i = 0; i < 15; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedList64floatGenericHasExpectedCapacity()
    {
        var list = new FixedList64<float>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedList64floatGenericInsertRange()
    {
        var list = new FixedList64<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemoveRange()
    {
        var list = new FixedList64<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericInsert()
    {
        var list = new FixedList64<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericRemove()
    {
        var list = new FixedList64<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList64floatGenericSort()
    {
        var list = new FixedList64<float>();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericHasExpectedLayout()
    {
        var actual = new FixedList128<float>();
        for (var i = 0; i < 31; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for (var i = 0; i < 31; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedList128floatGenericHasExpectedCapacity()
    {
        var list = new FixedList128<float>();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedList128floatGenericInsertRange()
    {
        var list = new FixedList128<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemoveRange()
    {
        var list = new FixedList128<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericInsert()
    {
        var list = new FixedList128<float>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericRemove()
    {
        var list = new FixedList128<float>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for (var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedList128floatGenericSort()
    {
        var list = new FixedList128<float>();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat32HasExpectedLayout()
    {
        var actual = new FixedListFloat32();
        for (var i = 0; i < 7; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[32];
            e[0] = (byte)((7 >> 0) & 0xFF);
            e[1] = (byte)((7 >> 8) & 0xFF);
            for (var i = 0; i < 7; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 32));
        }
    }

    [Test]
    public void FixedListFloat32HasExpectedCapacity()
    {
        var list = new FixedListFloat32();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedListFloat32InsertRange()
    {
        var list = new FixedListFloat32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat32 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListFloat32RemoveAt()
    {
        var list = new FixedListFloat32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32RemoveRange()
    {
        var list = new FixedListFloat32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32RemoveAtSwapBack()
    {
        var list = new FixedListFloat32();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat32RemoveRangeSwapBack()
    {
        var list = new FixedListFloat32();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat32Insert()
    {
        var list = new FixedListFloat32();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat32Sort()
    {
        var list = new FixedListFloat32();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat32ToFixedListFloat64()
    {
        var a = new FixedListFloat32();
        for (var i = 0; i < 7; ++i)
            a.Add((float)i);
        var b = new FixedListFloat64(a);
        for (var i = 0; i < 7; ++i)
            Assert.AreEqual((float)i, b[i]);
    }

    [Test]
    public void FixedListFloat32ToFixedListFloat128()
    {
        var a = new FixedListFloat32();
        for (var i = 0; i < 7; ++i)
            a.Add((float)i);
        var b = new FixedListFloat128(a);
        for (var i = 0; i < 7; ++i)
            Assert.AreEqual((float)i, b[i]);
    }

    [Test]
    public void FixedListFloat64HasExpectedLayout()
    {
        var actual = new FixedListFloat64();
        for (var i = 0; i < 15; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[64];
            e[0] = (byte)((15 >> 0) & 0xFF);
            e[1] = (byte)((15 >> 8) & 0xFF);
            for (var i = 0; i < 15; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 64));
        }
    }

    [Test]
    public void FixedListFloat64HasExpectedCapacity()
    {
        var list = new FixedListFloat64();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedListFloat64InsertRange()
    {
        var list = new FixedListFloat64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat64 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListFloat64RemoveAt()
    {
        var list = new FixedListFloat64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64RemoveRange()
    {
        var list = new FixedListFloat64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64RemoveAtSwapBack()
    {
        var list = new FixedListFloat64();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat64RemoveRangeSwapBack()
    {
        var list = new FixedListFloat64();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat64Insert()
    {
        var list = new FixedListFloat64();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat64Sort()
    {
        var list = new FixedListFloat64();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat64ToFixedListFloat32()
    {
        var a = new FixedListFloat64();
        for (var i = 0; i < 15; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListFloat32(a); });
    }

    [Test]
    public void FixedListFloat64ToFixedListFloat128()
    {
        var a = new FixedListFloat64();
        for (var i = 0; i < 15; ++i)
            a.Add((float)i);
        var b = new FixedListFloat128(a);
        for (var i = 0; i < 15; ++i)
            Assert.AreEqual((float)i, b[i]);
    }

    [Test]
    public void FixedListFloat128HasExpectedLayout()
    {
        var actual = new FixedListFloat128();
        for (var i = 0; i < 31; ++i)
            actual.Add((float)i);
        unsafe
        {
            var e = stackalloc byte[128];
            e[0] = (byte)((31 >> 0) & 0xFF);
            e[1] = (byte)((31 >> 8) & 0xFF);
            for (var i = 0; i < 31; ++i)
            {
                var s = (float)i;
                UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<float>() + sizeof(float) * i, &s, sizeof(float));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, 128));
        }
    }

    [Test]
    public void FixedListFloat128HasExpectedCapacity()
    {
        var list = new FixedListFloat128();
        var expectedCapacity = list.Capacity;
        for (int i = 0; i < expectedCapacity; ++i)
            list.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { list.Add((float)expectedCapacity); });
    }

    [Test]
    public void FixedListFloat128InsertRange()
    {
        var list = new FixedListFloat128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1, 3);
        list[1] = 1;
        list[2] = 2;
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref FixedListFloat128 list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void FixedListFloat128RemoveAt()
    {
        var list = new FixedListFloat128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128RemoveRange()
    {
        var list = new FixedListFloat128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128RemoveAtSwapBack()
    {
        var list = new FixedListFloat128();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void FixedListFloat128RemoveRangeSwapBack()
    {
        var list = new FixedListFloat128();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1, 3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void FixedListFloat128Insert()
    {
        var list = new FixedListFloat128();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1, 1);
        list.Insert(2, 2);
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat128Sort()
    {
        var list = new FixedListFloat128();
        for (var i = 0; i < 5; ++i)
            list.Add((float)(4 - i));
        list.Sort();
        for (var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void FixedListFloat128ToFixedListFloat32()
    {
        var a = new FixedListFloat128();
        for (var i = 0; i < 31; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListFloat32(a); });
    }

    [Test]
    public void FixedListFloat128ToFixedListFloat64()
    {
        var a = new FixedListFloat128();
        for (var i = 0; i < 31; ++i)
            a.Add((float)i);
        Assert.Throws<IndexOutOfRangeException>(() => { var b = new FixedListFloat64(a); });
    }
}
