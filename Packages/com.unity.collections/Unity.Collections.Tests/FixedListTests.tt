<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections.Tests/FixedListTests.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using System.Threading;
using NUnit.Framework;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

internal class FixedListTests
{
    struct NonComparableStruct
    {
        public int a;
    }

<#
    {
        var SIZES = new int[] {32, 64, 128};
        for (var size = 0; size < 3; ++size)
        {
            var BYTES = SIZES[size];
            var TYPENAME = String.Format("FixedList{0}", BYTES);
#>
    [Test]
    public void <#=TYPENAME #>DebugView()
    {
        var list = new <#=TYPENAME #><NonComparableStruct>();
        CollectionAssert.IsEmpty(new <#=TYPENAME #>DebugView<NonComparableStruct>(list).Items);

        var reference = new []
        {
            new NonComparableStruct{ a = 123 },
            new NonComparableStruct{ a = 234 },
            new NonComparableStruct{ a = 345 },
        };

        list.Add(reference[0]);
        list.Add(reference[1]);
        list.Add(reference[2]);

        CollectionAssert.AreEqual(reference, new <#=TYPENAME #>DebugView<NonComparableStruct>(list).Items);
    }

<#
        }
    }
    {
        var TYPES = new string[] {"byte", "int", "float"};
        var TYPESIZES = new int[] {1, 4, 4};
        var SIZES = new int[] {32, 64, 128};
        for (var type = 0; type < 3; ++type)
        {
            for (var size = 0; size < 3; ++size)
            {
                var BYTES = SIZES[size];
                var TYPE = TYPES[type];
                var TYPESIZE = TYPESIZES[type];
                var MAXLENGTH = BYTES - 2;
                var TYPENAME = String.Format("FixedList{0}", BYTES);
                var EXPECTEDCAPACITY = (BYTES - 2) / TYPESIZE;
#>

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericHasExpectedLayout()
    {
        var actual = new <#=TYPENAME #><<#=TYPE#>>();
        for(var i = 0; i < <#=EXPECTEDCAPACITY #>; ++i)
          actual.Add((<#=TYPE #>)i);
        unsafe
        {
            var e = stackalloc byte[<#=BYTES #>];
            e[0] = (byte)((<#=EXPECTEDCAPACITY #> >> 0) & 0xFF);
            e[1] = (byte)((<#=EXPECTEDCAPACITY #> >> 8) & 0xFF);
            for(var i = 0; i < <#=EXPECTEDCAPACITY #>; ++i)
            {
              var s = (<#=TYPE #>)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<<#=TYPE#>>() + sizeof(<#=TYPE #>) * i, &s, sizeof(<#=TYPE #>));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, <#=BYTES #>));
        }
    }

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericHasExpectedCapacity()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((<#=TYPE #>)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((<#=TYPE #>)expectedCapacity); });
    }
<#
                if (EXPECTEDCAPACITY >= 5)
                {
#>
    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericInsertRange()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericRemoveRange()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1,3);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericInsert()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericRemove()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        for(var i = 0; i < 3; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void <#=TYPENAME #><#=TYPE#>GenericSort()
    {
        var list = new <#=TYPENAME #><<#=TYPE#>>();
        for(var i = 0; i < 5; ++i)
          list.Add((<#=TYPE #>)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }
<#
                }
            }
            for (var size = 0; size < 3; ++size)
            {
                var BYTES = SIZES[size];
                var TYPE = TYPES[type];
                var TYPESIZE = TYPESIZES[type];
                var MAXLENGTH = BYTES - 2;
                var TYPENAME = String.Format("FixedList{0}{1}", new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE),
                    BYTES);
                var EXPECTEDCAPACITY = (BYTES - 2) / TYPESIZE;
#>

    [Test]
    public void <#=TYPENAME #>HasExpectedLayout()
    {
        var actual = new <#=TYPENAME #>();
        for(var i = 0; i < <#=EXPECTEDCAPACITY #>; ++i)
          actual.Add((<#=TYPE #>)i);
        unsafe
        {
            var e = stackalloc byte[<#=BYTES #>];
            e[0] = (byte)((<#=EXPECTEDCAPACITY #> >> 0) & 0xFF);
            e[1] = (byte)((<#=EXPECTEDCAPACITY #> >> 8) & 0xFF);
            for(var i = 0; i < <#=EXPECTEDCAPACITY #>; ++i)
            {
              var s = (<#=TYPE #>)i;
              UnsafeUtility.MemCpy(e + 2 + FixedList.PaddingBytes<<#=TYPE#>>() + sizeof(<#=TYPE #>) * i, &s, sizeof(<#=TYPE #>));
            }
            Assert.AreEqual(0, UnsafeUtility.MemCmp(e, &actual.length, <#=BYTES #>));
        }
    }

    [Test]
    public void <#=TYPENAME #>HasExpectedCapacity()
    {
        var list = new <#=TYPENAME #>();
        var expectedCapacity = list.Capacity;
        for(int i = 0; i < expectedCapacity; ++i)
            list.Add((<#=TYPE #>)i);
        Assert.Throws<IndexOutOfRangeException> (() => { list.Add((<#=TYPE #>)expectedCapacity); });
    }
<#
                if (EXPECTEDCAPACITY >= 5)
                {
#>
    [Test]
    public void <#=TYPENAME #>InsertRange()
    {
        var list = new <#=TYPENAME #>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.InsertRange(1,3);
        list[1] = 1;
        list[2] = 2;
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    private static void Expected(ref <#=TYPENAME #> list, int expectedLength, int[] expected)
    {
        Assert.AreEqual(list.Length, expectedLength);
        for (var i = 0; i < list.Length; ++i)
        {
            Assert.AreEqual(expected[i], list[i]);
        }
    }

    [Test]
    public void <#=TYPENAME #>RemoveAt()
    {
        var list = new <#=TYPENAME #>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAt(1);
        list.RemoveAt(1);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void <#=TYPENAME #>RemoveRange()
    {
        var list = new <#=TYPENAME #>();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRange(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void <#=TYPENAME #>RemoveAtSwapBack()
    {
        var list = new <#=TYPENAME #>();
        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveAtSwapBack(1);
        list.RemoveAtSwapBack(1);
        Expected(ref list, 3, new int[] { 0, 1, 3 });
    }

    [Test]
    public void <#=TYPENAME #>RemoveRangeSwapBack()
    {
        var list = new <#=TYPENAME #>();

        list.Add(0);
        list.Add(3);
        list.Add(3);
        list.Add(1);
        list.Add(2);
        list.RemoveRangeSwapBack(1,3);
        Expected(ref list, 3, new int[] { 0, 1, 2 });
    }

    [Test]
    public void <#=TYPENAME #>Insert()
    {
        var list = new <#=TYPENAME #>();
        list.Add(0);
        list.Add(3);
        list.Add(4);
        list.Insert(1,1);
        list.Insert(2,2);
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

    [Test]
    public void <#=TYPENAME #>Sort()
    {
        var list = new <#=TYPENAME #>();
        for(var i = 0; i < 5; ++i)
          list.Add((<#=TYPE #>)(4-i));
        list.Sort();
        for(var i = 0; i < 5; ++i)
            Assert.AreEqual(i, list[i]);
    }

<#
                }

                foreach (var OTHERBYTES in SIZES)
                {
                    if (OTHERBYTES != BYTES)
                    {
                        var OTHERCAPACITY = (OTHERBYTES - 2) / TYPESIZE;
                        var OTHERTYPENAME = String.Format("FixedList{0}{1}",
                            new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE), OTHERBYTES);
#>
    [Test]
    public void <#=TYPENAME #>To<#=OTHERTYPENAME #>()
    {
        var a = new <#=TYPENAME #>();
        for(var i = 0; i < <#=EXPECTEDCAPACITY #>; ++i)
            a.Add((<#=TYPE #>)i);
<#
                        if (EXPECTEDCAPACITY <= OTHERCAPACITY)
                        {
                            WriteLine("        var b = new {0}(a);", OTHERTYPENAME);
                            WriteLine("        for(var i = 0; i < {0}; ++i)", EXPECTEDCAPACITY);
                            WriteLine("            Assert.AreEqual(({0})i, b[i]);", TYPE);
                        }
                        else
                            WriteLine(
                                "        Assert.Throws<IndexOutOfRangeException> (() => {{ var b = new {0}(a); }} );",
                                OTHERTYPENAME);
#>
    }
<#
                    }
                }
            }
        }
    }
#>

}
