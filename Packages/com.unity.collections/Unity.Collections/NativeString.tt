<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/NativeString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// We have defined fixed-size NativeStrings, all of which are value types with zero allocation.
// You can copy them freely without ever generating garbage or needing to Dispose, but they are limited in size.
// If you want no size restrictions - if you want one type that works equally well for 1 character or 1,000,000,000 -
// you're better off using C#'s garbage-collected String type.
//
// NativeString32 - consumes 32 bytes of memory. suitable for short names. cacheline-sized on ARM
// NativeString64 - consumes 64 bytes of memory. suitable for names and descriptions. cacheline sized on non-ARM
// NativeString128 - consumes 128 bytes of memory. can hold a line of text.
// NativeString512 - consumes 512 bytes of memory.
// NativeString4096 - consumes 4096 bytes of memory. can hold a printed page of text.

using System;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Collections
{
    internal unsafe struct NativeString
    {
        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            var c = stackalloc char[Length * 2];
            int length = 0;
            Unicode.Utf8ToUtf16(data, Length, c, out length, Length * 2);
            return new String(c, 0, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return (int)CollectionHelper.Hash(data, Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="aa"></param>
        /// <param name="b"></param>
        /// <param name="bb"></param>
        /// <returns></returns>
        public static unsafe int CompareTo(byte *a, int aa, byte* b, int bb)
        {
            int chars = aa < bb ? aa : bb;
            for (var i = 0; i < chars; ++i)
            {
                if (a[i] < b[i])
                    return -1;
                if (a[i] > b[i])
                    return 1;
            }
            if (aa < bb)
                return -1;
            if (aa > bb)
                return 1;
            return 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="aa"></param>
        /// <param name="b"></param>
        /// <param name="bb"></param>
        /// <returns></returns>
        public static unsafe bool Equals(byte *a, int aa, byte* b, int bb)
        {
            if (aa != bb)
                return false;
            return UnsafeUtility.MemCmp(a, b, aa) == 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsDigit(Unicode.Rune c)
        {
            return c.value >= '0' && c.value <= '9';
        }

        /// <summary>
        /// </summary>
        public int Length;

        /// <summary>
        /// </summary>
        public int Capacity;

        /// <summary>
        /// </summary>
        public byte* data;

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <returns></returns>
        public Unicode.Rune Peek(int offset)
        {
            if (offset >= Length)
                return Unicode.BadRune;
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <returns></returns>
        public Unicode.Rune Read(ref int offset)
        {
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="rune"></param>
        public void Write(ref int offset, Unicode.Rune rune)
        {
            Unicode.UcsToUtf8(data, ref offset, Capacity, rune);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            long value = 0;
            int sign = 1;
            int digits = 0;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                value *= 10;
                value += Read(ref offset).value - '0';
                if(value >> 32 != 0)
                    return ParseError.Overflow;
                ++digits;
            }
            if (digits == 0)
                return ParseError.Syntax;
            value = sign * value;
            if(value > Int32.MaxValue)
                return ParseError.Overflow;
            if (value < Int32.MinValue)
                return ParseError.Overflow;
            output = (int)value;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        [StructLayout(LayoutKind.Explicit)]
        internal struct UintFloatUnion
        {
            [FieldOffset(0)]
            public uint uintValue;
            [FieldOffset(0)]
            public float floatValue;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="output"></param>
        /// <param name="mantissa10"></param>
        /// <param name="exponent10"></param>
        /// <returns></returns>
        static ParseError Base10ToBase2(ref float output, ulong mantissa10, int exponent10)
        {
            if (mantissa10 == 0)
            {
                output = 0.0f;
                return ParseError.None;
            }
            if (exponent10 == 0)
            {
                output = mantissa10;
                return ParseError.None;
            }
            var exponent2 = exponent10;
            var mantissa2 = mantissa10;
            while (exponent10 > 0)
            {
                while ((mantissa2 & 0xe000000000000000U) != 0)
                {
                    mantissa2 >>= 1;
                    ++exponent2;
                }
                mantissa2 *= 5;
                --exponent10;
            }
            while(exponent10 < 0)
            {
                while ((mantissa2 & 0x8000000000000000U) == 0)
                {
                    mantissa2 <<= 1;
                    --exponent2;
                }
                mantissa2 /= 5;
                ++exponent10;
            }
            // TODO: implement math.ldexpf (which presumably handles denormals (i don't))
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = mantissa2;
            var e = (int)((ufu.uintValue >> 23) & 0xFFU) - 127;
            e += exponent2;
            if (e > 128)
                return ParseError.Overflow;
            if (e < -127)
                return ParseError.Underflow;
            ufu.uintValue = (ufu.uintValue & ~(0xFFU<<23)) | ((uint)(e + 127) << 23);
            output = ufu.floatValue;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="mantissa10"></param>
        /// <param name="exponent10"></param>
        /// <param name="input"></param>
        public static void Base2ToBase10(ref ulong mantissa10, ref int exponent10, float input)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if(ufu.uintValue == 0)
            {
                mantissa10 = 0;
                exponent10 = 0;
                return;
            }
            var mantissa2 = (ufu.uintValue & ((1<<23)-1)) | (1 << 23);
            var exponent2 = (int) (ufu.uintValue >> 23) - 127 - 23;
            mantissa10 = mantissa2;
            exponent10 = exponent2;
            if (exponent2 > 0)
            {
                while (exponent2 > 0)
                {
                    // denormalize mantissa10 as much as you can, to minimize loss when doing /5 below.
                    while (mantissa10 <= UInt64.MaxValue/10)
                    {
                        mantissa10 *= 10;
                        --exponent10;
                    }
                    mantissa10 /= 5;
                    --exponent2;
                }
            }
            if (exponent2 < 0)
            {
                while (exponent2 < 0)
                {
                    // normalize mantissa10 just as much as you need, in order to make the *5 below not overflow.
                    while (mantissa10 > UInt64.MaxValue/5)
                    {
                        mantissa10 /= 10;
                        ++exponent10;
                    }
                    mantissa10 *= 5;
                    ++exponent2;
                }
            }
            // normalize mantissa10
            while (mantissa10 > 9999999U || mantissa10 % 10 == 0)
            {
                mantissa10 = (mantissa10 + 5) / 10;
                ++exponent10;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public FormatError Format(char a)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c, char d, char e, char f, char g, char h)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = d});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = e});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = f});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = g});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = h});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <param name="sourceLength"></param>
        /// <param name="decimalExponent"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError FormatScientific(char *source, int sourceLength, int decimalExponent, char decimalSeparator)
        {
            FormatError error;
            if ((error = Format(source[0])) != FormatError.None)
                return error;
            if (sourceLength > 1)
            {
                if ((error = Format(decimalSeparator)) != FormatError.None)
                    return error;
                for (var i = 1; i < sourceLength; ++i)
                {
                    if ((error = Format(source[i])) != FormatError.None)
                        return error;
                }
            }
            if ((error = Format('E')) != FormatError.None)
                return error;
            if (decimalExponent < 0)
            {
                if ((error = Format('-')) != FormatError.None)
                    return error;
                decimalExponent *= -1;
            }
            else
                if ((error = Format('+')) != FormatError.None)
                    return error;
            var ascii = stackalloc char[2];
            decimalExponent -= sourceLength - 1;
            const int decimalDigits = 2;
            for(var i = 0; i < decimalDigits; ++i)
            {
                var decimalDigit = decimalExponent % 10;
                ascii[1 - i] = (char)('0'+decimalDigit);
                decimalExponent /= 10;
            }
            for(var i = 0; i < decimalDigits; ++i)
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            const int maximumDigits = 20;
            var temp = stackalloc byte[maximumDigits];
            int offset = maximumDigits;
            if(input >= 0)
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' + digit);
                    input /= 10;
                } while(input != 0);
            }
            else
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' - digit);
                    input /= 10;
                } while(input != 0);
                temp[--offset] = (byte)'-';
            }
            var newLength = maximumDigits - offset;
            if(newLength > Capacity)
                return FormatError.Overflow;
            Length = newLength;
            UnsafeUtility.MemCpy(data, temp + offset, Length);
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            return Format((long)input);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if (ufu.uintValue == 4290772992U)
                return Format('N', 'a', 'N');
            var sign = ufu.uintValue >> 31;
            ufu.uintValue &= ~(1 << 31);
            FormatError error;
            if (sign != 0 && ufu.uintValue != 0) // C# prints -0 as 0
                if ((error = Format('-')) != FormatError.None)
                    return error;
            if(ufu.uintValue == 2139095040U)
                return Format( 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y');
            ulong decimalMantissa = 0;
            int decimalExponent = 0;
            Base2ToBase10(ref decimalMantissa, ref decimalExponent, ufu.floatValue);
            var backwards = stackalloc char[9];
            int decimalDigits = 0;
            do
            {
                if (decimalDigits >= 9)
                    return FormatError.Overflow;
                var decimalDigit = decimalMantissa % 10;
                backwards[8-decimalDigits++] = (char) ('0' + decimalDigit);
                decimalMantissa /= 10;
            } while (decimalMantissa > 0);
            char *ascii = backwards + 9 - decimalDigits;
            var leadingZeroes = -decimalExponent - decimalDigits + 1;
            if (leadingZeroes > 0)
            {
                if (leadingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                if ((error = Format('0', decimalSeparator)) != FormatError.None)
                    return error;
                --leadingZeroes;
                while (leadingZeroes > 0)
                {
                    if ((error = Format( '0')) != FormatError.None)
                        return error;
                    --leadingZeroes;
                }
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format( ascii[i])) != FormatError.None)
                        return error;
                }
                return FormatError.None;
            }
            var trailingZeroes = decimalExponent;
            if (trailingZeroes > 0)
            {
                if (trailingZeroes > 4)
                    return FormatScientific(  ascii, decimalDigits, decimalExponent, decimalSeparator);
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format( ascii[i])) != FormatError.None)
                        return error;
                }
                while (trailingZeroes > 0)
                {
                    if ((error = Format( '0')) != FormatError.None)
                        return error;
                    --trailingZeroes;
                }
                return FormatError.None;
            }
            var indexOfSeparator = decimalDigits + decimalExponent;
            for (var i = 0; i < decimalDigits; ++i)
            {
                if (i == indexOfSeparator)
                    if ((error = Format(decimalSeparator)) != FormatError.None)
                        return error;
                if ((error = Format( ascii[i])) != FormatError.None)
                    return error;
            }
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c)
        {
            int old = offset;
            if((Read(ref offset).value|32) == a
            && (Read(ref offset).value|32) == b
            && (Read(ref offset).value|32) == c)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c, char d, char e, char f, char g, char h)
        {
            int old = offset;
            if((Read(ref offset).value|32) == a
            && (Read(ref offset).value|32) == b
            && (Read(ref offset).value|32) == c
            && (Read(ref offset).value|32) == d
            && (Read(ref offset).value|32) == e
            && (Read(ref offset).value|32) == f
            && (Read(ref offset).value|32) == g
            && (Read(ref offset).value|32) == h)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator)
        {
            if(Found(ref offset, 'n', 'a', 'n'))
            {
                UintFloatUnion ufu = new UintFloatUnion();
                ufu.uintValue = 4290772992U;
                output = ufu.floatValue;
                return ParseError.None;
            }
            int sign = 1;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            ulong decimalMantissa = 0;
            int significantDigits = 0;
            int digitsAfterDot = 0;
            int mantissaDigits = 0;
            if(Found(ref offset, 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'))
            {
                output = (sign == 1) ? Single.PositiveInfinity : Single.NegativeInfinity;
                return ParseError.None;
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                ++mantissaDigits;
                if (significantDigits < 9)
                {
                    var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                    if (temp > decimalMantissa)
                        ++significantDigits;
                    decimalMantissa = temp;
                }
                else
                    --digitsAfterDot;
                Read(ref offset);
            }
            if (offset < Length && Peek(offset).value == decimalSeparator)
            {
                Read(ref offset);
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++mantissaDigits;
                    if (significantDigits < 9)
                    {
                        var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                        if (temp > decimalMantissa)
                            ++significantDigits;
                        decimalMantissa = temp;
                        ++digitsAfterDot;
                    }
                    Read(ref offset);
                }
            }
            if (mantissaDigits == 0)
                return ParseError.Syntax;
            int decimalExponent = 0;
            int decimalExponentSign = 1;
            if (offset < Length && (Peek(offset).value|32) == 'e')
            {
                Read(ref offset);
                if (offset < Length)
                {
                    if (Peek(offset).value == '+')
                        Read(ref offset);
                    else if (Peek(offset).value == '-')
                    {
                        decimalExponentSign = -1;
                        Read(ref offset);
                    }
                }
                int exponentDigits = 0;
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++exponentDigits;
                    decimalExponent = decimalExponent * 10 + (Peek(offset).value - '0');
                    if (decimalExponent > 38)
                        if(decimalExponentSign == 1)
                            return ParseError.Overflow;
                        else
                            return ParseError.Underflow;
                    Read(ref offset);
                }
                if (exponentDigits == 0)
                    return ParseError.Syntax;
            }
            decimalExponent = decimalExponent * decimalExponentSign - digitsAfterDot;
            var error = Base10ToBase2(ref output, decimalMantissa, decimalExponent);
            if (error != ParseError.None)
                return error;
            output *= sign;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destMaxLength, char *src, int srcLength)
        {
            if(ConversionError.None == Unicode.Utf16ToUtf8(src, srcLength, dest, out destLength, destMaxLength))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destMaxLength, byte *src, int srcLength)
        {
            destLength = srcLength > destMaxLength ? destMaxLength : srcLength;
            UnsafeUtility.MemCpy(dest, src, destLength);
            return destLength == srcLength ? CopyError.None : CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out int destLength, int destMaxLength, byte *src, int srcLength)
        {
            if(ConversionError.None == Unicode.Utf8ToUtf16(src, srcLength, dest, out destLength, destMaxLength))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destMaxLength, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destMaxLength, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(char *dest, ref ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=1)]
    public struct Bytes1
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=16)]
    public struct Bytes16
    {
<#
    for(var i = 0; i < 16; ++i)
    {
       var offset = i.ToString("D4");
#>
        /// <summary>
        /// </summary>
        [FieldOffset(<#=i#>)] public byte byte<#=offset#>;
<#
    }
#>
    }

<#
{
    var SIZES = new int[]{32,64,128,512,4096};
    foreach (var BYTES in SIZES) {
      var MAXLENGTH = BYTES - 2;
#>

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=<#=MAXLENGTH#>)]
    public struct Bytes<#=MAXLENGTH#>
    {
<#
      var freeBytes = MAXLENGTH % 16;
      for(var i = 0; i < freeBytes; ++i)
      {
        var offset = i.ToString("D4");
#>
        /// <summary>
        /// </summary>
        [FieldOffset(<#=i#>)] public byte byte<#=offset#>;
<#
      }
      for(var i = 0; i < MAXLENGTH / 16; ++i)
      {
        var offset = freeBytes + i * 16;
        var offs = offset.ToString("D4");
#>
        /// <summary>
        /// </summary>
        [FieldOffset(<#=offset#>)] public Bytes16 byte<#=offs#>;
<#
      }
#>
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=<#=BYTES#>)]
    public struct NativeString<#=BYTES#> : IComparable<NativeString<#=BYTES#>>, IEquatable<NativeString<#=BYTES#>>
    {
        public const int MaxLength = <#=MAXLENGTH#>;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes<#=MAXLENGTH#> buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes<#=MAXLENGTH#>* b = &buffer)
                    return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString{data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

<#
    foreach (var OTHERBYTES in SIZES)
    {

#>
        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString<#=OTHERBYTES#> source)
        {
            fixed(byte * b = &buffer.byte0000)
                return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString<#=OTHERBYTES#> source)
        {
            fixed (byte* b = &buffer.byte0000)
                return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

<#
        if(OTHERBYTES != BYTES)
        {
#>
        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString<#=BYTES#>(ref NativeString<#=OTHERBYTES#> source)
        {
            LengthInBytes = 0;
            buffer = new Bytes<#=MAXLENGTH#>{};
            var error = CopyFrom(source);
            if(error != CopyError.None)
                throw new ArgumentException($"NativeString<#=BYTES#>: {error} while copying \"{source}\"");
        }

<#
        }
    }
#>

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed (byte* b = &buffer.byte0000)
                return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
                return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed (byte* b = &buffer.byte0000)
                return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed (byte* b = &buffer.byte0000)
                return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed (byte* b = &buffer.byte0000)
                return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed (byte* b = &buffer.byte0000)
                return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString<#=BYTES#>(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes<#=MAXLENGTH#>{};
            var error = CopyFrom(source);
            if(error != CopyError.None)
                throw new ArgumentException($"NativeString<#=BYTES#>: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString<#=BYTES#>(string b) => new NativeString<#=BYTES#>(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString<#=BYTES#> other)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString<#=BYTES#> other)
        {
            unsafe
            {
                fixed (byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString<#=BYTES#> other && Equals(other);
        }
    }
<#}}#>
}
