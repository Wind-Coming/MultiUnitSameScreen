<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Security.Cryptography" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedList.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using Unity.Collections.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using UnityEngine.Internal;
using System.Collections;
using Unity.Mathematics;

namespace Unity.Collections
{
    struct FixedList
    {
        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        internal static void CheckElementAccess(int index, int Length)
        {
            if (index < 0 || index >= Length)
                throw new IndexOutOfRangeException($"Index {index} is out of range of '{Length}' Length.");
        }

        internal static int PaddingBytes<T>() where T : struct
        {
            return math.max(0, math.min(6, (1 << math.tzcnt(UnsafeUtility.SizeOf<T>())) - 2));
        }

        internal static int StorageBytes<BUFFER,T>() where BUFFER : struct where T : struct
        {
            return UnsafeUtility.SizeOf<BUFFER>() - PaddingBytes<T>();
        }

        internal static int Capacity<BUFFER,T>() where BUFFER : struct where T : struct
        {
            return StorageBytes<BUFFER,T>() / UnsafeUtility.SizeOf<T>();
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        internal static void CheckResize<BUFFER,T>(int newLength) where BUFFER : struct where T : struct
        {
            var Capacity = Capacity<BUFFER,T>();
            if (newLength < 0 || newLength > Capacity)
                throw new IndexOutOfRangeException($"NewLength {newLength} is out of range of '{Capacity}' Capacity.");
        }
    }

<#
var SIZES = new int[]{32,64,128,512,4096};
for(var size = 0; size < 5; ++size)
{
    var BYTES = SIZES[size];
    var BUFFER_BYTES = BYTES - 2;
    var TYPENAME = String.Format("FixedList{0}", BYTES);
#>
    /// <summary>
    /// An unmanaged, resizable list that does not allocate memory.
    /// It is <#=BYTES#> bytes in size, and contains all the memory it needs.
    /// </summary>
    /// <typeparam name="T">The type of the elements in the container.</typeparam>
    [DebuggerTypeProxy(typeof(<#=TYPENAME#>DebugView<>))]
    public struct <#=TYPENAME#><T>
    : INativeList<T>, IEnumerable<T>
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = String.Format("FixedList{0}", OTHERBYTES);
        WriteLine("    , IEquatable<{0}<T>>", OTHERTYPENAME);
        WriteLine("    , IComparable<{0}<T>>", OTHERTYPENAME);
    }
#>    where T : unmanaged
    {
        internal ushort length;
        internal FixedBytes<#=BUFFER_BYTES#> buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes<#=BUFFER_BYTES#>,T>(value);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * UnsafeUtility.SizeOf<T>();

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<T>();
            }
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
          get
          {
              return FixedList.Capacity<FixedBytes<#=BUFFER_BYTES#>,T>();
          }
          set
          {
              CheckCapacityInRange(value);
          }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public T this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index));
                }
            }
            set
            {
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<T>(Buffer, CollectionHelper.AssumePositive(index), value);
                }
            }
        }

        public ref T ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtilityEx.ArrayElementAsRef<T>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The T to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(in T item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Determines whether an element is in the <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="item">The object to locate in the <#=TYPENAME#>&lt;T&gt;.</param>
        /// <returns></returns>
        public bool Contains(in T item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified T and returns the zero-based index of the first occurrence within the
        /// range of elements in the <#=TYPENAME#>&lt;T&gt; that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The T to locate in the <#=TYPENAME#>&lt;T&gt;.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        public int IndexOf(in T item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified T and returns the zero-based index of the first occurrence within the
        /// range of elements in the <#=TYPENAME#>&lt;T&gt; that starts at the specified index.
        /// </summary>
        /// <param name="item">The T to locate in the <#=TYPENAME#>&lt;T&gt;.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        public int IndexOf(in T item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Searches for the specified T and returns the zero-based index of the first occurrence within the entire <#=TYPENAME#>.
        /// </summary>
        /// <param name="item">The T to locate in the <#=TYPENAME#>&lt;T&gt;.</param>
        /// <returns></returns>
        public int IndexOf(T item)
        {
            return IndexOf(item, 0, Length);
        }

        /// <summary>
        /// Inserts a number of items into a <#=TYPENAME#>&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end"></param>
        public void InsertRange(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * UnsafeUtility.SizeOf<T>();
            unsafe
            {
                byte *b = Buffer;
                byte *dest = b + end * UnsafeUtility.SizeOf<T>();
                byte *src = b + begin * UnsafeUtility.SizeOf<T>();
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a <#=TYPENAME#>&lt;T&gt; at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, in T item)
        {
            InsertRange(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBack(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the <#=TYPENAME#>&lt;T&gt; and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the <#=TYPENAME#>&lt;T&gt;.</param>
        public void RemoveSwapBack(in T item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        public void RemoveRangeSwapBack(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, math.min(itemsToRemove, Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Truncates the list by removing the item at the specified index, and shifting all remaining items to replace removed item. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        /// <remarks>
        /// This method of removing item is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveAtSwapBack`.
        /// </remarks>
        public void RemoveAt(int index)
        {
            RemoveRange(index, index + 1);
        }

        /// <summary>
        /// Searches for the specified T from the begining of the <#=TYPENAME#>&lt;T&gt; forward, removes it if possible,
        /// and returns true if the T was successfully removed.
        /// </summary>
        /// <param name="item">The T to locate in the <#=TYPENAME#>&lt;T&gt;</param>
        /// <returns></returns>
        public bool Remove(in T item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBack`.
        /// </remarks>
        public void RemoveRange(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = UnsafeUtility.SizeOf<T>();
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of T that is a copy of this <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <returns></returns>
        public T[] ToArray()
        {
            var result = new T[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(T* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray&lt;T&gt; that is a copy of this <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<T> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(s, Length, Allocator.None);
                return new NativeArray<T>(copy, allocator);
            }
        }

<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHER_BUFFER_BYTES = OTHERBYTES - 2;
        var OTHERTYPENAME = String.Format("FixedList{0}", OTHERBYTES);
#>

        /// <summary>
        /// Determines whether a <#=TYPENAME#>&lt;T&gt; and <#=OTHERTYPENAME#>&lt;T&gt; have the same value.
        /// </summary>
        /// <param name="a">The <#=TYPENAME#>&lt;T&gt; to compare for equality</param>
        /// <param name="b">The <#=OTHERTYPENAME#>&lt;T&gt; to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in <#=TYPENAME#><T> a, in <#=OTHERTYPENAME#><T> b)
        {
            unsafe
            {
                if(a.length != b.length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a <#=TYPENAME#>&lt;T&gt; and <#=OTHERTYPENAME#>&lt;T&gt; have different values.
        /// </summary>
        /// <param name="a">The <#=TYPENAME#>&lt;T&gt; to compare for inequality</param>
        /// <param name="b">The <#=OTHERTYPENAME#>&lt;T&gt; to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in <#=TYPENAME#><T> a, in <#=OTHERTYPENAME#><T> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified <#=OTHERTYPENAME#>&lt;T&gt; and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified <#=OTHERTYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified <#=OTHERTYPENAME#>&lt;T&gt; to compare with</param>
        /// <returns></returns>
        public int CompareTo(<#=OTHERTYPENAME#><T> other)
        {
            unsafe
            {
                fixed(byte* a = &buffer.offset0000.byte0000)
                {
                    byte* b = &other.buffer.offset0000.byte0000;
                    var aa = a + FixedList.PaddingBytes<T>();
                    var bb = b + FixedList.PaddingBytes<T>();
                    var mini = math.min(Length, other.Length);
                    for(var i = 0; i < mini; ++i)
                    {
                        var j = UnsafeUtility.MemCmp(aa + sizeof(T) * i, bb + sizeof(T) * i, sizeof(T));
                        if(j != 0)
                            return j;
                    }
                    return Length.CompareTo(other.Length);
                }
            }
        }

        /// <summary>
        /// Compares this instance with a specified <#=OTHERTYPENAME#>&lt;T&gt; and indicates whether this instance
        /// is equal to the specified <#=OTHERTYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="other">The specified <#=OTHERTYPENAME#>&lt;T&gt; to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(<#=OTHERTYPENAME#><T> other)
        {
            return CompareTo(other) == 0;
        }

<#
        if(BYTES != OTHERBYTES)
        {
#>

        /// <summary>
        /// Constructs a new <#=TYPENAME#>&lt;T&gt; that is a copy of a <#=OTHERTYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="other">The <#=OTHERTYPENAME#>&lt;T&gt; to copy</param>
        public <#=TYPENAME#>(in <#=OTHERTYPENAME#><T> other)
        {
            FixedList.CheckResize<FixedBytes<#=BUFFER_BYTES#>,T>(other.length);
            length = other.length;
            buffer = new FixedBytes<#=BUFFER_BYTES#>();
            unsafe
            {
                UnsafeUtility.MemCpy(Buffer, other.Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Implicitly converts a <#=OTHERTYPENAME#>&lt;T&gt; to a <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="other">The <#=OTHERTYPENAME#>&lt;T&gt; to copy</param>
        /// <returns></returns>
        public static implicit operator <#=TYPENAME#><T>(in <#=OTHERTYPENAME#><T> other)
        {
            return new <#=TYPENAME#><T>(other);
        }
<#
        }
    }
#>

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = String.Format("FixedList{0}", OTHERBYTES);
        WriteLine("            if(obj is {0}<T> a{0}) return Equals(a{0});", OTHERTYPENAME);
    }
#>
            return false;
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<T>
        {
            <#=TYPENAME#><T> m_List;
            int m_Index;

            public Enumerator(ref <#=TYPENAME#><T> list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let <#=TYPENAME#><T> indexer check for out of range.
            public T Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<T> IEnumerable<T>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class <#=TYPENAME#>DebugView<T> where T : unmanaged
    {
        <#=TYPENAME#><T> m_List;
        public <#=TYPENAME#>DebugView(<#=TYPENAME#><T> list)
        {
            m_List = list;
        }
        public T[] Items => m_List.ToArray();
    }
<#
}
#>

<#
var TYPES = new string[]{"byte","int","float"};
var TYPESIZES = new int[]{1,4,4};
for(var type = 0; type < 3; ++type)
for(var size = 0; size < 5; ++size)
{
    var BYTES = SIZES[size];
    var TYPE = TYPES[type];
    var TYPESIZE = TYPESIZES[type];
    var BUFFER_BYTES = BYTES - 2;
    var TYPENAME = String.Format("FixedList{0}{1}", new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE), BYTES);
#>

    /// <summary>
    /// An unmanaged, resizable list of <#=TYPE#> that does not allocate memory.
    /// It is <#=BYTES#> bytes in size, and contains all the memory it needs.
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size=<#=BYTES#>)]
    [DebuggerTypeProxy(typeof(<#=TYPENAME#>DebugView))]
    public struct <#=TYPENAME#>
    : INativeList<<#=TYPE#>>, IEnumerable<<#=TYPE#>>
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = String.Format("FixedList{0}{1}", new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE), OTHERBYTES);
        WriteLine("    , IEquatable<{0}>", OTHERTYPENAME);
        WriteLine("    , IComparable<{0}>", OTHERTYPENAME);
    }
#>
    {
        [FieldOffset(0)] internal ushort length;
        [FieldOffset(2)] internal FixedBytes<#=BUFFER_BYTES#> buffer;

        /// <summary>
        /// The current number of items in the list.
        /// </summary>
        /// <value>The item length.</value>
        public int Length
        {
            get => length;
            set
            {
                FixedList.CheckResize<FixedBytes<#=BUFFER_BYTES#>,<#=TYPE#>>(value);
                length = (ushort)value;
            }
        }

        internal int LengthInBytes => Length * sizeof(<#=TYPE#>);

        unsafe internal byte* Buffer
        {
            get
            {
                fixed(byte* b = &buffer.offset0000.byte0000)
                    return b + FixedList.PaddingBytes<<#=TYPE#>>();
            }
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        /// <summary>
        /// The number of items that can fit in the list.
        /// </summary>
        /// <value>The number of items that the list can hold.</value>
        /// <remarks>Capacity specifies the number of items the list can currently hold. You can not change Capacity
        /// to fit more or fewer items.</remarks>
        public int Capacity
        {
            get
            {
                return FixedList.Capacity<FixedBytes<#=BUFFER_BYTES#>, <#=TYPE#>>();
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        /// <summary>
        /// Retrieve a member of the list by index.
        /// </summary>
        /// <param name="index">The zero-based index into the list.</param>
        /// <value>The list item at the specified index.</value>
        /// <exception cref="IndexOutOfRangeException">Thrown if index is negative or >= to <see cref="Length"/>.</exception>
        public <#=TYPE#> this[int index]
        {
            get
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    return UnsafeUtility.ReadArrayElement<<#=TYPE#>>(Buffer, index);
                }
            }
            set
            {
                FixedList.CheckElementAccess(index, length);
                unsafe
                {
                    UnsafeUtility.WriteArrayElement<<#=TYPE#>>(Buffer, index, value);
                }
            }
        }

        public ref <#=TYPE#> ElementAt(int index)
        {
            FixedList.CheckElementAccess(index, length);
            unsafe
            {
                return ref UnsafeUtilityEx.ArrayElementAsRef<<#=TYPE#>>(Buffer, index);
            }
        }

        /// <summary>
        /// Computes a hash code summary of the <#=TYPENAME#>.
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                return (int)CollectionHelper.Hash(Buffer, LengthInBytes);
            }
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void Add(<#=TYPE#> item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Adds an element to the list.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to be added at the end of the list.</param>
        /// <exception cref="IndexOutOfRangeException">Thrown if list is already full. See <see cref="Capacity"/>.</exception>
        public void AddNoResize(<#=TYPE#> item)
        {
            this[Length++] = item;
        }

        /// <summary>
        /// Clears the list.
        /// </summary>
        public void Clear()
        {
            Length = 0;
        }

        /// <summary>
        /// Determines whether an element is in the <#=TYPENAME#>.
        /// </summary>
        /// <param name="item">The object to locate in the <#=TYPENAME#>.</param>
        /// <returns></returns>
        public bool Contains(<#=TYPE#> item)
        {
            return IndexOf(item) >= 0;
        }

        /// <summary>
        /// Searches for the specified <#=TYPE#> and returns the zero-based index of the first occurrence within the
        /// range of elements in the <#=TYPENAME#> that starts at the specified index and contains the specified
        /// number of elements.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to locate in the <#=TYPENAME#>.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <param name="count">The number of elements in the section to search.</param>
        /// <returns></returns>
        public int IndexOf(<#=TYPE#> item, int index, int count)
        {
            for(var i = index; i < index + count; ++i)
                if(this[i].Equals(item))
                  return i;
            return -1;
        }

        /// <summary>
        /// Searches for the specified <#=TYPE#> and returns the zero-based index of the first occurrence within the
        /// range of elements in the <#=TYPENAME#> that starts at the specified index.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to locate in the <#=TYPENAME#>.</param>
        /// <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        /// <returns></returns>
        public int IndexOf(<#=TYPE#> item, int index)
        {
            return IndexOf(item, index, Length - index);
        }

        /// <summary>
        /// Searches for the specified <#=TYPE#> and returns the zero-based index of the first occurrence within the entire <#=TYPENAME#>.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to locate in the <#=TYPENAME#>.</param>
        /// <returns></returns>
        public int IndexOf(<#=TYPE#> item)
        {
            return IndexOf(item, 0, Length);
        }

        /// <summary>
        /// Inserts a number of items into a <#=TYPENAME#> at a specified zero-based index.
        /// </summary>
        /// <param name="begin">The zero-based index at which the new elements should be inserted.</param>
        /// <param name="end">The zero-based index just after where the elements should be removed.</param>
        public void InsertRange(int begin, int end)
        {
            int items = end - begin;
            if(items < 1)
                return;
            int itemsToCopy = length - begin;
            Length += items;
            if(itemsToCopy < 1)
                return;
            int bytesToCopy = itemsToCopy * sizeof(<#=TYPE#>);
            unsafe
            {
                byte* b = Buffer;
                byte *dest = b + end * sizeof(<#=TYPE#>);
                byte *src = b + begin * sizeof(<#=TYPE#>);
                UnsafeUtility.MemMove(dest, src, bytesToCopy);
            }
        }

        /// <summary>
        /// Inserts a single element into a <#=TYPENAME#> at a specified zero-based index.
        /// </summary>
        /// <param name="index">The zero-based index at which the new element should be inserted.</param>
        /// <param name="item">The element to insert</param>
        public void Insert(int index, <#=TYPE#> item)
        {
            InsertRange(index, index+1);
            this[index] = item;
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index with the last item in the list. The list
        /// is shortened by one.
        /// </summary>
        /// <param name="index">The index of the item to delete.</param>
        public void RemoveAtSwapBack(int index)
        {
            RemoveRangeSwapBack(index, index + 1);
        }

        /// <summary>
        /// Removes the first occurrence of an item from the <#=TYPENAME#> and replaces it with the last element,
        /// which can be much faster than copying down all subsequent elements.
        /// </summary>
        /// <param name="item">The elements to remove from the <#=TYPENAME#>.</param>
        public void RemoveSwapBack(<#=TYPE#> item)
        {
            var index = IndexOf(item);
            if(index == -1)
                return;
            RemoveAtSwapBack(index);
        }

        /// <summary>
        /// Truncates the list by replacing the item at the specified index range with the items from the end the list. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        public void RemoveRangeSwapBack(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                int copyFrom = math.max(Length - itemsToRemove, end);

                unsafe
                {
                    var sizeOf = sizeof(<#=TYPE#>);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, math.min(itemsToRemove, Length - copyFrom) * sizeOf);
                }

                Length -= itemsToRemove;
            }
        }

        /// <summary>
        /// Removes the <#=TYPE#> at the specified index, and copies all subsequent elements backward to fill the
        /// hole so created.
        /// </summary>
        /// <param name="index">The zero-based index at which to remove the <#=TYPE#></param>
        public void RemoveAt(int index)
        {
            RemoveRange(index, index+1);
        }

        /// <summary>
        /// Searches for the specified <#=TYPE#> from the begining of the <#=TYPENAME#> forward, removes it if possible,
        /// and returns true if the <#=TYPE#> was successfully removed.
        /// </summary>
        /// <param name="item">The <#=TYPE#> to locate in the <#=TYPENAME#></param>
        /// <returns></returns>
        public bool Remove(<#=TYPE#> item)
        {
            int index = IndexOf(item);
            if(index < 0)
                return false;
            RemoveRange(index, index+1);
            return true;
        }

        /// <summary>
        /// Truncates the list by removing the items at the specified index range, and shifting all remaining items to replace removed items. The list
        /// is shortened by number of elements in range.
        /// </summary>
        /// <param name="begin">The first index of the item to remove.</param>
        /// <param name="end">The index past-the-last item to remove.</param>
        /// <remarks>
        /// This method of removing item(s) is useful only in case when list is ordered and user wants to preserve order
        /// in list after removal In majority of cases is not important and user should use more performant `RemoveRangeSwapBack`.
        /// </remarks>
        public void RemoveRange(int begin, int end)
        {
            int itemsToRemove = end - begin;
            if (itemsToRemove > 0)
            {
                unsafe
                {
                    var sizeOf = sizeof(<#=TYPE#>);
                    int copyFrom = math.min(begin + itemsToRemove, Length);
                    void* dst = Buffer + begin * sizeOf;
                    void* src = Buffer + copyFrom * sizeOf;
                    UnsafeUtility.MemCpy(dst, src, (Length - copyFrom) * sizeOf);
                    Length -= itemsToRemove;
                }
            }
        }

        /// <summary>
        /// Creates a managed Array of <#=TYPE#> that is a copy of this <#=TYPENAME#>.
        /// </summary>
        /// <returns></returns>
        public <#=TYPE#>[] ToArray()
        {
            var result = new <#=TYPE#>[Length];
            unsafe
            {
                byte* s = Buffer;
                fixed(<#=TYPE#>* d = result)
                    UnsafeUtility.MemCpy(d, s, LengthInBytes);
            }
            return result;
        }

        /// <summary>
        /// Creates an unmanaged NativeArray<#=TYPE#> that is a copy of this <#=TYPENAME#>.
        /// </summary>
        /// <param name="allocator">A member of the
        /// [Unity.Collections.Allocator](https://docs.unity3d.com/ScriptReference/Unity.Collections.Allocator.html) enumeration.</param>
        /// <returns></returns>
        public NativeArray<<#=TYPE#>> ToNativeArray(Allocator allocator)
        {
            unsafe
            {
                byte* s = Buffer;
                var copy = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<<#=TYPE#>>(s, Length, Allocator.None);
                return new NativeArray<<#=TYPE#>>(copy, allocator);
            }
        }

        /// <summary>
        /// Sorts the elements in this <#=TYPENAME#>.
        /// </summary>
        public void Sort()
        {
            unsafe
            {
                NativeSortExtension.Sort((<#=TYPE#>*)Buffer, length);
            }
        }
<#
foreach(var OTHERBYTES in SIZES)
{
    var OTHER_BUFFER_BYTES = OTHERBYTES - 2;
    var OTHERTYPENAME = String.Format("FixedList{0}{1}", new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE), OTHERBYTES);
#>

        /// <summary>
        /// Determines whether a <#=TYPENAME#> and <#=OTHERTYPENAME#> have the same value.
        /// </summary>
        /// <param name="a">The <#=TYPENAME#> to compare for equality</param>
        /// <param name="b">The <#=OTHERTYPENAME#> to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in <#=TYPENAME#> a, in <#=OTHERTYPENAME#> b)
        {
            unsafe
            {
                if(a.Length != b.Length)
                    return false;
                return UnsafeUtility.MemCmp(a.Buffer, b.Buffer, a.LengthInBytes) == 0;
            }
        }

        /// <summary>
        /// Determines whether a <#=TYPENAME#> and <#=OTHERTYPENAME#> have different values.
        /// </summary>
        /// <param name="a">The <#=TYPENAME#> to compare for inequality</param>
        /// <param name="b">The <#=OTHERTYPENAME#> to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in <#=TYPENAME#> a, in <#=OTHERTYPENAME#> b)
        {
            return !(a == b);
        }

        /// <summary>
        /// Compares this instance with a specified <#=OTHERTYPENAME#> and indicates whether this instance
        /// precedes, follows, or appears in the same position in the sort order as the specified <#=OTHERTYPENAME#>.
        /// </summary>
        /// <param name="other">The specified <#=OTHERTYPENAME#> to compare with</param>
        /// <returns></returns>
        public int CompareTo(<#=OTHERTYPENAME#> other)
        {
            unsafe
            {
                var mini = math.min(Length, other.Length);
                for(var i = 0; i < mini; ++i)
                {
                    var j = this[i].CompareTo(other[i]);
                    if(j != 0)
                        return j;
                }
                return Length.CompareTo(other.Length);
            }
        }

        /// <summary>
        /// Compares this instance with a specified <#=OTHERTYPENAME#> and indicates whether this instance
        /// is equal to the specified <#=OTHERTYPENAME#>.
        /// </summary>
        /// <param name="other">The specified <#=OTHERTYPENAME#> to compare with for equality</param>
        /// <returns></returns>
        public bool Equals(<#=OTHERTYPENAME#> other)
        {
            return CompareTo(other) == 0;
        }

<#
    if(BYTES != OTHERBYTES)
    {
#>

        /// <summary>
        /// Constructs a new <#=TYPENAME#> that is a copy of a <#=OTHERTYPENAME#>.
        /// </summary>
        /// <param name="other">The <#=OTHERTYPENAME#> to copy</param>
        public <#=TYPENAME#>(in <#=OTHERTYPENAME#> other)
        {
            FixedList.CheckResize<FixedBytes<#=BUFFER_BYTES#>,<#=TYPE#>>(other.length);
            length = other.length;
            buffer = new FixedBytes<#=BUFFER_BYTES#>();
            unsafe
            {
                fixed(FixedBytes<#=OTHER_BUFFER_BYTES#>* s = &other.buffer)
                fixed(FixedBytes<#=BUFFER_BYTES#>* d = &this.buffer)
<#
        if(OTHERBYTES >= BYTES)
            WriteLine("                    *d = *(FixedBytes{0}*)s;", BUFFER_BYTES);
        else
            WriteLine("                    *(FixedBytes{0}*)d = *s;", OTHER_BUFFER_BYTES);
#>
            }
        }

        /// <summary>
        /// Implicitly converts a <#=OTHERTYPENAME#> to a <#=TYPENAME#>.
        /// </summary>
        /// <param name="other">The <#=OTHERTYPENAME#> to copy</param>
        /// <returns></returns>
        public static implicit operator <#=TYPENAME#>(in <#=OTHERTYPENAME#> other)
        {
            return new <#=TYPENAME#>(other);
        }
<#
    }
}
#>

        /// <summary>
        /// Compares this instance with a specified object and indicates whether this instance
        /// is equal to the specified object.
        /// </summary>
        /// <param name="obj">The specified object to compare with for equality</param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = String.Format("FixedList{0}{1}", new CultureInfo("en-US").TextInfo.ToTitleCase(TYPE), OTHERBYTES);
        WriteLine("            if(obj is {0} a{0}) return Equals(a{0});", OTHERTYPENAME);
    }
#>
            return false;
        }

        [ExcludeFromDocs]
        public struct Enumerator : IEnumerator<<#=TYPE#>>
        {
            <#=TYPENAME#> m_List;
            int m_Index;

            public Enumerator(ref <#=TYPENAME#> list)
            {
                m_List = list;
                m_Index = -1;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
                m_Index++;
                return m_Index < m_List.Length;
            }

            public void Reset()
            {
                m_Index = -1;
            }

            // Let <#=TYPENAME#> indexer check for out of range.
            public <#=TYPE#> Current => m_List[m_Index];

            object IEnumerator.Current => Current;
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(ref this);
        }

        IEnumerator IEnumerable.GetEnumerator() { throw new NotImplementedException(); }
        IEnumerator<<#=TYPE#>> IEnumerable<<#=TYPE#>>.GetEnumerator() { throw new NotImplementedException(); }
    }

    sealed class <#=TYPENAME#>DebugView
    {
        <#=TYPENAME#> m_List;
        public <#=TYPENAME#>DebugView(<#=TYPENAME#> list)
        {
            m_List = list;
        }
        public <#=TYPE#>[] Items => m_List.ToArray();
    }

<#
}
#>
    public static class Extensions
    {
<#
for(var size = 0; size < 5; ++size)
{
    var BYTES = SIZES[size];
    var BUFFER_BYTES = BYTES - 2;
    var TYPENAME = String.Format("FixedList{0}", BYTES);
#>

        /// <summary>
        /// Sorts the elements in this <#=TYPENAME#>&lt;T&gt;.
        /// </summary>
        /// <param name="data">Container to perform search.</param>
        /// <typeparam name="T">The type of the elements in the container.</typeparam>
        public static void Sort<T>(this ref <#=TYPENAME#><T> data)
        where T : unmanaged, IComparable<T>
        {
            unsafe
            {
                fixed(byte* b = &data.buffer.offset0000.byte0000)
                {
                    var c = b + FixedList.PaddingBytes<T>();
                    NativeSortExtension.Sort((T*)c, data.Length);
                }
            }
        }

<#
}
#>
    }
}
