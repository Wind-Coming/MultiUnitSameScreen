//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Internal;
using System.Diagnostics;

namespace Unity.Collections
{
    public struct FixedString
    {
        internal unsafe struct Formatter
        {
            public FixedString128 result;
            public FixedString128 *format;
            public FixedString32 arg0;
            public FixedString32 arg1;
            public FixedString32 arg2;
            public void Format()
            {
                ref var resultBytes = ref result.AsFixedList;
                ref var formatBytes = ref format->AsFixedList;
                for (var i = 0; i < formatBytes.Length; ++i)
                {
                    if (formatBytes[i] == '{')
                    {
                        if (formatBytes.Length - i >= 3 && formatBytes[i + 1] != '{')
                        {
                            var index = formatBytes[i + 1] - '0';
                            switch (index)
                            {
                                case 0: result.Append(arg0); i += 2; break;
                                case 1: result.Append(arg1); i += 2; break;
                                case 2: result.Append(arg2); i += 2; break;
                                default: resultBytes.Add(formatBytes[i]); break;
                            }
                        }
                    }
                    else
                        resultBytes.Add(formatBytes[i]);
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameter a.</returns>
        public static FixedString128 Format(in FixedString128 format, int a)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, int b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, int, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, int b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, int, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, int b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, int, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, int b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, float b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, float, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, float b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, float, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, float b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, float, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, float b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, in FixedString32 b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, in FixedString32, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, in FixedString32 b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, in FixedString32, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, in FixedString32 b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a int, in FixedString32, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type int</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, int a, in FixedString32 b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameter a.</returns>
        public static FixedString128 Format(in FixedString128 format, float a)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, int b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, int, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, int b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, int, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, int b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, int, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, int b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, float b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, float, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, float b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, float, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, float b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, float, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, float b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, in FixedString32 b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, in FixedString32, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, in FixedString32 b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, in FixedString32, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, in FixedString32 b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a float, in FixedString32, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type float</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, float a, in FixedString32 b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameter a.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32 and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, int b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, int, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, int b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, int, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, int b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, int, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type int</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, int b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32 and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, float b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, float, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, float b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, float, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, float b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, float, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type float</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, float b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32 and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, in FixedString32 b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, in FixedString32, and int argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type int</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, in FixedString32 b, int c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, in FixedString32, and float argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type float</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, in FixedString32 b, float c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a in FixedString32, in FixedString32, and in FixedString32 argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type in FixedString32</param>
        /// <param name="b">A parameter of type in FixedString32</param>
        /// <param name="c">A parameter of type in FixedString32</param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, in FixedString32 a, in FixedString32 b, in FixedString32 c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }
    }

    internal unsafe struct Generic
    {
        public override String ToString()
        {
            var c = stackalloc char[Length * 2];
            int length = 0;
            Unicode.Utf8ToUtf16(data, Length, c, out length, Length * 2);
            return new String(c, 0, length);
        }

        public override int GetHashCode()
        {
            return (int)CollectionHelper.Hash(data, Length);
        }

        public static unsafe int IndexOf(byte *a, int aa, byte* b, int bb)
        {
            for (var i = 0; i <= aa - bb; ++i)
            {
                for (var j = 0; j < bb; ++j)
                    if (a[i + j] != b[j])
                        goto end_of_loop;
                return i;
                end_of_loop : {}
            }
            return -1;
        }

        public static unsafe int LastIndexOf(byte *a, int aa, byte* b, int bb)
        {
            for (var i = aa - bb; i >= 0; --i)
            {
                for (var j = 0; j < bb; ++j)
                    if (a[i + j] != b[j])
                        goto end_of_loop;
                return i;
                end_of_loop : {}
            }
            return -1;
        }

        public static unsafe int CompareTo(byte *a, int aa, byte* b, int bb)
        {
            int chars = aa < bb ? aa : bb;
            for (var i = 0; i < chars; ++i)
            {
                if (a[i] < b[i])
                    return -1;
                if (a[i] > b[i])
                    return 1;
            }
            if (aa < bb)
                return -1;
            if (aa > bb)
                return 1;
            return 0;
        }

        public static unsafe bool Equals(byte *a, int aa, byte* b, int bb)
        {
            if (aa != bb)
                return false;
            if (a == b)
                return true;
            return CompareTo(a, aa, b, bb) == 0;
        }

        public static bool IsDigit(Unicode.Rune c)
        {
            return c.value >= '0' && c.value <= '9';
        }

        public int Length;
        public int Capacity;
        public byte* data;

        public Unicode.Rune Peek(int offset)
        {
            if (offset >= Length)
                return Unicode.BadRune;
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        public Unicode.Rune Read(ref int offset)
        {
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        public void Write(ref int offset, Unicode.Rune rune)
        {
            Unicode.UcsToUtf8(data, ref offset, Capacity, rune);
        }

        public ParseError Parse(ref int offset, ref int output)
        {
            long value = 0;
            int sign = 1;
            int digits = 0;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                value *= 10;
                value += Read(ref offset).value - '0';
                if (value >> 32 != 0)
                    return ParseError.Overflow;
                ++digits;
            }
            if (digits == 0)
                return ParseError.Syntax;
            value = sign * value;
            if (value > Int32.MaxValue)
                return ParseError.Overflow;
            if (value < Int32.MinValue)
                return ParseError.Overflow;
            output = (int)value;
            return ParseError.None;
        }

        [StructLayout(LayoutKind.Explicit)]
        internal struct UintFloatUnion
        {
            [FieldOffset(0)]
            public uint uintValue;
            [FieldOffset(0)]
            public float floatValue;
        }

        static ParseError Base10ToBase2(ref float output, ulong mantissa10, int exponent10)
        {
            if (mantissa10 == 0)
            {
                output = 0.0f;
                return ParseError.None;
            }
            if (exponent10 == 0)
            {
                output = mantissa10;
                return ParseError.None;
            }
            var exponent2 = exponent10;
            var mantissa2 = mantissa10;
            while (exponent10 > 0)
            {
                while ((mantissa2 & 0xe000000000000000U) != 0)
                {
                    mantissa2 >>= 1;
                    ++exponent2;
                }
                mantissa2 *= 5;
                --exponent10;
            }
            while (exponent10 < 0)
            {
                while ((mantissa2 & 0x8000000000000000U) == 0)
                {
                    mantissa2 <<= 1;
                    --exponent2;
                }
                mantissa2 /= 5;
                ++exponent10;
            }
            // TODO: implement math.ldexpf (which presumably handles denormals (i don't))
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = mantissa2;
            var e = (int)((ufu.uintValue >> 23) & 0xFFU) - 127;
            e += exponent2;
            if (e > 128)
                return ParseError.Overflow;
            if (e < -127)
                return ParseError.Underflow;
            ufu.uintValue = (ufu.uintValue & ~(0xFFU << 23)) | ((uint)(e + 127) << 23);
            output = ufu.floatValue;
            return ParseError.None;
        }

        public static void Base2ToBase10(ref ulong mantissa10, ref int exponent10, float input)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if (ufu.uintValue == 0)
            {
                mantissa10 = 0;
                exponent10 = 0;
                return;
            }
            var mantissa2 = (ufu.uintValue & ((1 << 23) - 1)) | (1 << 23);
            var exponent2 = (int)(ufu.uintValue >> 23) - 127 - 23;
            mantissa10 = mantissa2;
            exponent10 = exponent2;
            if (exponent2 > 0)
            {
                while (exponent2 > 0)
                {
                    // denormalize mantissa10 as much as you can, to minimize loss when doing /5 below.
                    while (mantissa10 <= UInt64.MaxValue / 10)
                    {
                        mantissa10 *= 10;
                        --exponent10;
                    }
                    mantissa10 /= 5;
                    --exponent2;
                }
            }
            if (exponent2 < 0)
            {
                while (exponent2 < 0)
                {
                    // normalize mantissa10 just as much as you need, in order to make the *5 below not overflow.
                    while (mantissa10 > UInt64.MaxValue / 5)
                    {
                        mantissa10 /= 10;
                        ++exponent10;
                    }
                    mantissa10 *= 5;
                    ++exponent2;
                }
            }
            // normalize mantissa10
            while (mantissa10 > 9999999U || mantissa10 % 10 == 0)
            {
                mantissa10 = (mantissa10 + (mantissa10 < 100000000U ? 5u : 0u)) / 10;
                ++exponent10;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public FormatError Format(char a)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c, char d, char e, char f, char g, char h)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = d});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = e});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = f});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = g});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = h});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <param name="sourceLength"></param>
        /// <param name="decimalExponent"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError FormatScientific(char *source, int sourceLength, int decimalExponent, char decimalSeparator)
        {
            FormatError error;
            if ((error = Format(source[0])) != FormatError.None)
                return error;
            if (sourceLength > 1)
            {
                if ((error = Format(decimalSeparator)) != FormatError.None)
                    return error;
                for (var i = 1; i < sourceLength; ++i)
                {
                    if ((error = Format(source[i])) != FormatError.None)
                        return error;
                }
            }
            if ((error = Format('E')) != FormatError.None)
                return error;
            if (decimalExponent < 0)
            {
                if ((error = Format('-')) != FormatError.None)
                    return error;
                decimalExponent *= -1;
                decimalExponent -= sourceLength - 1;
            }
            else
            {
                if ((error = Format('+')) != FormatError.None)
                    return error;
                decimalExponent += sourceLength - 1;
            }
            var ascii = stackalloc char[2];
            const int decimalDigits = 2;
            for (var i = 0; i < decimalDigits; ++i)
            {
                var decimalDigit = decimalExponent % 10;
                ascii[1 - i] = (char)('0' + decimalDigit);
                decimalExponent /= 10;
            }
            for (var i = 0; i < decimalDigits; ++i)
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            const int maximumDigits = 20;
            var temp = stackalloc byte[maximumDigits];
            int offset = maximumDigits;
            if (input >= 0)
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' + digit);
                    input /= 10;
                }
                while (input != 0);
            }
            else
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' - digit);
                    input /= 10;
                }
                while (input != 0);
                temp[--offset] = (byte)'-';
            }
            var newLength = maximumDigits - offset;
            if (newLength > Capacity)
                return FormatError.Overflow;
            Length = newLength;
            UnsafeUtility.MemCpy(data, temp + offset, Length);
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            return Format((long)input);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            var sign = ufu.uintValue >> 31;
            ufu.uintValue &= ~(1 << 31);
            FormatError error;
            if ((ufu.uintValue & 0x7F800000) == 0x7F800000)
            {
                if (ufu.uintValue == 0x7F800000)
                {
                    if (sign != 0 && ((error = Format('-')) != FormatError.None))
                        return error;
                    return Format('I', 'n', 'f', 'i', 'n', 'i', 't', 'y');
                }
                return Format('N', 'a', 'N');
            }
            if (sign != 0 && ufu.uintValue != 0) // C# prints -0 as 0
                if ((error = Format('-')) != FormatError.None)
                    return error;
            ulong decimalMantissa = 0;
            int decimalExponent = 0;
            Base2ToBase10(ref decimalMantissa, ref decimalExponent, ufu.floatValue);
            var backwards = stackalloc char[9];
            int decimalDigits = 0;
            do
            {
                if (decimalDigits >= 9)
                    return FormatError.Overflow;
                var decimalDigit = decimalMantissa % 10;
                backwards[8 - decimalDigits++] = (char)('0' + decimalDigit);
                decimalMantissa /= 10;
            }
            while (decimalMantissa > 0);
            char *ascii = backwards + 9 - decimalDigits;
            var leadingZeroes = -decimalExponent - decimalDigits + 1;
            if (leadingZeroes > 0)
            {
                if (leadingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                if ((error = Format('0', decimalSeparator)) != FormatError.None)
                    return error;
                --leadingZeroes;
                while (leadingZeroes > 0)
                {
                    if ((error = Format('0')) != FormatError.None)
                        return error;
                    --leadingZeroes;
                }
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format(ascii[i])) != FormatError.None)
                        return error;
                }
                return FormatError.None;
            }
            var trailingZeroes = decimalExponent;
            if (trailingZeroes > 0)
            {
                if (trailingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format(ascii[i])) != FormatError.None)
                        return error;
                }
                while (trailingZeroes > 0)
                {
                    if ((error = Format('0')) != FormatError.None)
                        return error;
                    --trailingZeroes;
                }
                return FormatError.None;
            }
            var indexOfSeparator = decimalDigits + decimalExponent;
            for (var i = 0; i < decimalDigits; ++i)
            {
                if (i == indexOfSeparator)
                    if ((error = Format(decimalSeparator)) != FormatError.None)
                        return error;
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            }
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c)
        {
            int old = offset;
            if ((Read(ref offset).value | 32) == a
                && (Read(ref offset).value | 32) == b
                && (Read(ref offset).value | 32) == c)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c, char d, char e, char f, char g, char h)
        {
            int old = offset;
            if ((Read(ref offset).value | 32) == a
                && (Read(ref offset).value | 32) == b
                && (Read(ref offset).value | 32) == c
                && (Read(ref offset).value | 32) == d
                && (Read(ref offset).value | 32) == e
                && (Read(ref offset).value | 32) == f
                && (Read(ref offset).value | 32) == g
                && (Read(ref offset).value | 32) == h)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator)
        {
            if (Found(ref offset, 'n', 'a', 'n'))
            {
                UintFloatUnion ufu = new UintFloatUnion();
                ufu.uintValue = 4290772992U;
                output = ufu.floatValue;
                return ParseError.None;
            }
            int sign = 1;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            ulong decimalMantissa = 0;
            int significantDigits = 0;
            int digitsAfterDot = 0;
            int mantissaDigits = 0;
            if (Found(ref offset, 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'))
            {
                output = (sign == 1) ? Single.PositiveInfinity : Single.NegativeInfinity;
                return ParseError.None;
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                ++mantissaDigits;
                if (significantDigits < 9)
                {
                    var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                    if (temp > decimalMantissa)
                        ++significantDigits;
                    decimalMantissa = temp;
                }
                else
                    --digitsAfterDot;
                Read(ref offset);
            }
            if (offset < Length && Peek(offset).value == decimalSeparator)
            {
                Read(ref offset);
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++mantissaDigits;
                    if (significantDigits < 9)
                    {
                        var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                        if (temp > decimalMantissa)
                            ++significantDigits;
                        decimalMantissa = temp;
                        ++digitsAfterDot;
                    }
                    Read(ref offset);
                }
            }
            if (mantissaDigits == 0)
                return ParseError.Syntax;
            int decimalExponent = 0;
            int decimalExponentSign = 1;
            if (offset < Length && (Peek(offset).value | 32) == 'e')
            {
                Read(ref offset);
                if (offset < Length)
                {
                    if (Peek(offset).value == '+')
                        Read(ref offset);
                    else if (Peek(offset).value == '-')
                    {
                        decimalExponentSign = -1;
                        Read(ref offset);
                    }
                }
                int exponentDigits = 0;
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++exponentDigits;
                    decimalExponent = decimalExponent * 10 + (Peek(offset).value - '0');
                    if (decimalExponent > 38)
                        if (decimalExponentSign == 1)
                            return ParseError.Overflow;
                        else
                            return ParseError.Underflow;
                    Read(ref offset);
                }
                if (exponentDigits == 0)
                    return ParseError.Syntax;
            }
            decimalExponent = decimalExponent * decimalExponentSign - digitsAfterDot;
            var error = Base10ToBase2(ref output, decimalMantissa, decimalExponent);
            if (error != ParseError.None)
                return error;
            output *= sign;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destUTF8MaxLengthInBytes, char *src, int srcLength)
        {
            if (ConversionError.None == Unicode.Utf16ToUtf8(src, srcLength, dest, out destLength, destUTF8MaxLengthInBytes))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destUTF8MaxLengthInBytes, byte *src, int srcLength)
        {
            destLength = srcLength > destUTF8MaxLengthInBytes ? destUTF8MaxLengthInBytes : srcLength;
            UnsafeUtility.MemCpy(dest, src, destLength);
            return destLength == srcLength ? CopyError.None : CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out int destLength, int destUTF8MaxLengthInBytes, byte *src, int srcLength)
        {
            if (ConversionError.None == Unicode.Utf8ToUtf16(src, srcLength, dest, out destLength, destUTF8MaxLengthInBytes))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(char *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    internal struct FixedBytes16
    {
        [FieldOffset(0)] internal byte byte0000;
        [FieldOffset(1)] internal byte byte0001;
        [FieldOffset(2)] internal byte byte0002;
        [FieldOffset(3)] internal byte byte0003;
        [FieldOffset(4)] internal byte byte0004;
        [FieldOffset(5)] internal byte byte0005;
        [FieldOffset(6)] internal byte byte0006;
        [FieldOffset(7)] internal byte byte0007;
        [FieldOffset(8)] internal byte byte0008;
        [FieldOffset(9)] internal byte byte0009;
        [FieldOffset(10)] internal byte byte0010;
        [FieldOffset(11)] internal byte byte0011;
        [FieldOffset(12)] internal byte byte0012;
        [FieldOffset(13)] internal byte byte0013;
        [FieldOffset(14)] internal byte byte0014;
        [FieldOffset(15)] internal byte byte0015;
    }


    [StructLayout(LayoutKind.Explicit, Size = 30)]
    internal struct FixedBytes30
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal byte byte0016;
        [FieldOffset(17)] internal byte byte0017;
        [FieldOffset(18)] internal byte byte0018;
        [FieldOffset(19)] internal byte byte0019;
        [FieldOffset(20)] internal byte byte0020;
        [FieldOffset(21)] internal byte byte0021;
        [FieldOffset(22)] internal byte byte0022;
        [FieldOffset(23)] internal byte byte0023;
        [FieldOffset(24)] internal byte byte0024;
        [FieldOffset(25)] internal byte byte0025;
        [FieldOffset(26)] internal byte byte0026;
        [FieldOffset(27)] internal byte byte0027;
        [FieldOffset(28)] internal byte byte0028;
        [FieldOffset(29)] internal byte byte0029;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 32)]
    public struct FixedString32
        : INativeList<byte>
        , IComparable<String>
        , IEquatable<String>
        , IEquatable<FixedString32>
        , IEquatable<FixedString64>
        , IEquatable<FixedString128>
        , IEquatable<FixedString512>
        , IEquatable<FixedString4096>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes30 bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString32 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString32 of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes30* b = &bytes)
                    return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes30* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes30* b = &bytes)
                return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = 30;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString32 as a FixedListByte32, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte32 AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString32* t = &this)
                    return ref UnsafeUtilityEx.AsRef<FixedListByte32>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString32&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString32, at the byte offset indicated from the beginning
        /// of the FixedString32.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString32, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString32.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString32</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString32.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString32</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString32.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString32</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString32 that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString32(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for (var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if (error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString32 that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString32(char c, int count)
            : this(new Unicode.Rune {value = c}, count)
        {
        }

        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString32 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString32 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString32 onto this FixedString32.
        /// </summary>
        /// <param name="source">The 32 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int IndexOf(in FixedString32 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int LastIndexOf(in FixedString32 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return whether the FixedString32 was found or not.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <returns>
        /// true if the FixedString32 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString32 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString32 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString32 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString32 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString32 a, in FixedString32 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString32 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString32 a, in FixedString32 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString64 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString64 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString64 onto this FixedString32.
        /// </summary>
        /// <param name="source">The 64 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int IndexOf(in FixedString64 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int LastIndexOf(in FixedString64 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return whether the FixedString64 was found or not.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <returns>
        /// true if the FixedString64 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString64 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString64 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString64 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString64 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString32 a, in FixedString64 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString64 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString32 a, in FixedString64 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString32 from a FixedString64
        /// </summary>
        /// <param name="source">The 64 to construct this string from</param>
        public FixedString32(in FixedString64 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString64 to FixedString32.
        /// </summary>
        /// <param name="b">The FixedString64 object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(in FixedString64 source) => new FixedString32(source);


        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString128 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString128 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString128 onto this FixedString32.
        /// </summary>
        /// <param name="source">The 128 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int IndexOf(in FixedString128 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int LastIndexOf(in FixedString128 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return whether the FixedString128 was found or not.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <returns>
        /// true if the FixedString128 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString128 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString128 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString128 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString128 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString32 a, in FixedString128 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString128 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString32 a, in FixedString128 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString32 from a FixedString128
        /// </summary>
        /// <param name="source">The 128 to construct this string from</param>
        public FixedString32(in FixedString128 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString128 to FixedString32.
        /// </summary>
        /// <param name="b">The FixedString128 object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(in FixedString128 source) => new FixedString32(source);


        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString512 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString512 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString512 onto this FixedString32.
        /// </summary>
        /// <param name="source">The 512 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int IndexOf(in FixedString512 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int LastIndexOf(in FixedString512 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return whether the FixedString512 was found or not.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <returns>
        /// true if the FixedString512 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString512 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString512 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString512 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString512 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString32 a, in FixedString512 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString512 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString32 a, in FixedString512 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString32 from a FixedString512
        /// </summary>
        /// <param name="source">The 512 to construct this string from</param>
        public FixedString32(in FixedString512 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString512 to FixedString32.
        /// </summary>
        /// <param name="b">The FixedString512 object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(in FixedString512 source) => new FixedString32(source);


        /// <summary>
        /// Overwrite the contents of this FixedString32 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString4096 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString32.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString4096 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString4096 onto this FixedString32.
        /// </summary>
        /// <param name="source">The 4096 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int IndexOf(in FixedString4096 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int LastIndexOf(in FixedString4096 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return whether the FixedString4096 was found or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <returns>
        /// true if the FixedString4096 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString4096 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString4096 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString32 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString4096 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString4096 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString32 a, in FixedString4096 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString32 and FixedString4096 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString32 a, in FixedString4096 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString32 from a FixedString4096
        /// </summary>
        /// <param name="source">The 4096 to construct this string from</param>
        public FixedString32(in FixedString4096 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString4096 to FixedString32.
        /// </summary>
        /// <param name="b">The FixedString4096 object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(in FixedString4096 source) => new FixedString32(source);


        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString32 target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString32 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if (offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                    Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString32 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString32 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString32 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString32.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString32.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString32.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString32 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString32 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString32 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString32 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString32 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString32 with</param>
        public FixedString32(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString32.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString32</param>
        /// <returns></returns>
        public static implicit operator FixedString32(string b) => new FixedString32(b);

        /// <summary>
        /// Convert this FixedString32 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString32</returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString32: an integer that is likely to be different for
        /// two FixedString32, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString32</returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString32 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj is String aString) return Equals(aString);
            if (obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if (obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if (obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if (obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if (obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 62)]
    internal struct FixedBytes62
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal byte byte0048;
        [FieldOffset(49)] internal byte byte0049;
        [FieldOffset(50)] internal byte byte0050;
        [FieldOffset(51)] internal byte byte0051;
        [FieldOffset(52)] internal byte byte0052;
        [FieldOffset(53)] internal byte byte0053;
        [FieldOffset(54)] internal byte byte0054;
        [FieldOffset(55)] internal byte byte0055;
        [FieldOffset(56)] internal byte byte0056;
        [FieldOffset(57)] internal byte byte0057;
        [FieldOffset(58)] internal byte byte0058;
        [FieldOffset(59)] internal byte byte0059;
        [FieldOffset(60)] internal byte byte0060;
        [FieldOffset(61)] internal byte byte0061;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 64)]
    public struct FixedString64
        : INativeList<byte>
        , IComparable<String>
        , IEquatable<String>
        , IEquatable<FixedString32>
        , IEquatable<FixedString64>
        , IEquatable<FixedString128>
        , IEquatable<FixedString512>
        , IEquatable<FixedString4096>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes62 bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString64 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString64 of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes62* b = &bytes)
                    return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes62* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes62* b = &bytes)
                return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = 62;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString64 as a FixedListByte64, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte64 AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString64* t = &this)
                    return ref UnsafeUtilityEx.AsRef<FixedListByte64>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString64&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString64, at the byte offset indicated from the beginning
        /// of the FixedString64.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString64, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString64.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString64</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString64.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString64</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString64.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString64</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString64 that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString64(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for (var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if (error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString64 that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString64(char c, int count)
            : this(new Unicode.Rune {value = c}, count)
        {
        }

        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString32 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString32 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString32 onto this FixedString64.
        /// </summary>
        /// <param name="source">The 32 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int IndexOf(in FixedString32 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int LastIndexOf(in FixedString32 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return whether the FixedString32 was found or not.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <returns>
        /// true if the FixedString32 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString32 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString32 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString32 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString32 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString64 a, in FixedString32 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString32 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString64 a, in FixedString32 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString64 from a FixedString32
        /// </summary>
        /// <param name="source">The 32 to construct this string from</param>
        public FixedString64(in FixedString32 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString32 to FixedString64.
        /// </summary>
        /// <param name="b">The FixedString32 object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(in FixedString32 source) => new FixedString64(source);


        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString64 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString64 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString64 onto this FixedString64.
        /// </summary>
        /// <param name="source">The 64 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int IndexOf(in FixedString64 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int LastIndexOf(in FixedString64 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return whether the FixedString64 was found or not.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <returns>
        /// true if the FixedString64 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString64 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString64 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString64 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString64 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString64 a, in FixedString64 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString64 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString64 a, in FixedString64 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString128 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString128 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString128 onto this FixedString64.
        /// </summary>
        /// <param name="source">The 128 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int IndexOf(in FixedString128 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int LastIndexOf(in FixedString128 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return whether the FixedString128 was found or not.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <returns>
        /// true if the FixedString128 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString128 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString128 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString128 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString128 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString64 a, in FixedString128 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString128 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString64 a, in FixedString128 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString64 from a FixedString128
        /// </summary>
        /// <param name="source">The 128 to construct this string from</param>
        public FixedString64(in FixedString128 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString128 to FixedString64.
        /// </summary>
        /// <param name="b">The FixedString128 object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(in FixedString128 source) => new FixedString64(source);


        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString512 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString512 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString512 onto this FixedString64.
        /// </summary>
        /// <param name="source">The 512 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int IndexOf(in FixedString512 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int LastIndexOf(in FixedString512 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return whether the FixedString512 was found or not.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <returns>
        /// true if the FixedString512 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString512 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString512 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString512 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString512 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString64 a, in FixedString512 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString512 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString64 a, in FixedString512 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString64 from a FixedString512
        /// </summary>
        /// <param name="source">The 512 to construct this string from</param>
        public FixedString64(in FixedString512 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString512 to FixedString64.
        /// </summary>
        /// <param name="b">The FixedString512 object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(in FixedString512 source) => new FixedString64(source);


        /// <summary>
        /// Overwrite the contents of this FixedString64 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString4096 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString64.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString4096 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString4096 onto this FixedString64.
        /// </summary>
        /// <param name="source">The 4096 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int IndexOf(in FixedString4096 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int LastIndexOf(in FixedString4096 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return whether the FixedString4096 was found or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <returns>
        /// true if the FixedString4096 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString4096 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString4096 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString64 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString4096 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString4096 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString64 a, in FixedString4096 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString64 and FixedString4096 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString64 a, in FixedString4096 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString64 from a FixedString4096
        /// </summary>
        /// <param name="source">The 4096 to construct this string from</param>
        public FixedString64(in FixedString4096 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString4096 to FixedString64.
        /// </summary>
        /// <param name="b">The FixedString4096 object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(in FixedString4096 source) => new FixedString64(source);


        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString64 target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString64 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if (offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                    Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString64 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString64 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString64 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString64.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString64.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString64.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString64 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString64 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString64 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString64 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString64 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString64 with</param>
        public FixedString64(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString64.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString64</param>
        /// <returns></returns>
        public static implicit operator FixedString64(string b) => new FixedString64(b);

        /// <summary>
        /// Convert this FixedString64 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString64</returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString64: an integer that is likely to be different for
        /// two FixedString64, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString64</returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString64 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj is String aString) return Equals(aString);
            if (obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if (obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if (obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if (obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if (obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 126)]
    internal struct FixedBytes126
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal byte byte0112;
        [FieldOffset(113)] internal byte byte0113;
        [FieldOffset(114)] internal byte byte0114;
        [FieldOffset(115)] internal byte byte0115;
        [FieldOffset(116)] internal byte byte0116;
        [FieldOffset(117)] internal byte byte0117;
        [FieldOffset(118)] internal byte byte0118;
        [FieldOffset(119)] internal byte byte0119;
        [FieldOffset(120)] internal byte byte0120;
        [FieldOffset(121)] internal byte byte0121;
        [FieldOffset(122)] internal byte byte0122;
        [FieldOffset(123)] internal byte byte0123;
        [FieldOffset(124)] internal byte byte0124;
        [FieldOffset(125)] internal byte byte0125;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 128)]
    public struct FixedString128
        : INativeList<byte>
        , IComparable<String>
        , IEquatable<String>
        , IEquatable<FixedString32>
        , IEquatable<FixedString64>
        , IEquatable<FixedString128>
        , IEquatable<FixedString512>
        , IEquatable<FixedString4096>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes126 bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString128 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString128 of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes126* b = &bytes)
                    return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes126* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes126* b = &bytes)
                return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = 126;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString128 as a FixedListByte128, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte128 AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString128* t = &this)
                    return ref UnsafeUtilityEx.AsRef<FixedListByte128>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString128&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString128, at the byte offset indicated from the beginning
        /// of the FixedString128.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString128, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString128.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString128</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString128.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString128</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString128.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString128</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString128 that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString128(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for (var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if (error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString128 that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString128(char c, int count)
            : this(new Unicode.Rune {value = c}, count)
        {
        }

        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString32 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString32 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString32 onto this FixedString128.
        /// </summary>
        /// <param name="source">The 32 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int IndexOf(in FixedString32 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int LastIndexOf(in FixedString32 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return whether the FixedString32 was found or not.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <returns>
        /// true if the FixedString32 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString32 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString32 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString32 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString32 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString128 a, in FixedString32 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString32 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString128 a, in FixedString32 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString128 from a FixedString32
        /// </summary>
        /// <param name="source">The 32 to construct this string from</param>
        public FixedString128(in FixedString32 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString32 to FixedString128.
        /// </summary>
        /// <param name="b">The FixedString32 object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString32 source) => new FixedString128(source);


        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString64 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString64 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString64 onto this FixedString128.
        /// </summary>
        /// <param name="source">The 64 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int IndexOf(in FixedString64 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int LastIndexOf(in FixedString64 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return whether the FixedString64 was found or not.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <returns>
        /// true if the FixedString64 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString64 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString64 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString64 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString64 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString128 a, in FixedString64 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString64 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString128 a, in FixedString64 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString128 from a FixedString64
        /// </summary>
        /// <param name="source">The 64 to construct this string from</param>
        public FixedString128(in FixedString64 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString64 to FixedString128.
        /// </summary>
        /// <param name="b">The FixedString64 object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString64 source) => new FixedString128(source);


        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString128 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString128 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString128 onto this FixedString128.
        /// </summary>
        /// <param name="source">The 128 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int IndexOf(in FixedString128 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int LastIndexOf(in FixedString128 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return whether the FixedString128 was found or not.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <returns>
        /// true if the FixedString128 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString128 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString128 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString128 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString128 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString128 a, in FixedString128 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString128 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString128 a, in FixedString128 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString512 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString512 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString512 onto this FixedString128.
        /// </summary>
        /// <param name="source">The 512 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int IndexOf(in FixedString512 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int LastIndexOf(in FixedString512 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return whether the FixedString512 was found or not.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <returns>
        /// true if the FixedString512 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString512 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString512 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString512 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString512 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString128 a, in FixedString512 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString512 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString128 a, in FixedString512 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString128 from a FixedString512
        /// </summary>
        /// <param name="source">The 512 to construct this string from</param>
        public FixedString128(in FixedString512 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString512 to FixedString128.
        /// </summary>
        /// <param name="b">The FixedString512 object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString512 source) => new FixedString128(source);


        /// <summary>
        /// Overwrite the contents of this FixedString128 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString4096 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString128.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString4096 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString4096 onto this FixedString128.
        /// </summary>
        /// <param name="source">The 4096 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int IndexOf(in FixedString4096 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int LastIndexOf(in FixedString4096 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return whether the FixedString4096 was found or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <returns>
        /// true if the FixedString4096 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString4096 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString4096 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString128 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString4096 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString4096 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString128 a, in FixedString4096 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString128 and FixedString4096 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString128 a, in FixedString4096 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString128 from a FixedString4096
        /// </summary>
        /// <param name="source">The 4096 to construct this string from</param>
        public FixedString128(in FixedString4096 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString4096 to FixedString128.
        /// </summary>
        /// <param name="b">The FixedString4096 object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(in FixedString4096 source) => new FixedString128(source);


        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString128 target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString128 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if (offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                    Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString128 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString128 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString128 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString128.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString128.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString128.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString128 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString128 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString128 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString128 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString128 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString128 with</param>
        public FixedString128(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString128.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString128</param>
        /// <returns></returns>
        public static implicit operator FixedString128(string b) => new FixedString128(b);

        /// <summary>
        /// Convert this FixedString128 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString128</returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString128: an integer that is likely to be different for
        /// two FixedString128, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString128</returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString128 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj is String aString) return Equals(aString);
            if (obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if (obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if (obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if (obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if (obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 510)]
    internal struct FixedBytes510
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal FixedBytes16 offset0112;
        [FieldOffset(128)] internal FixedBytes16 offset0128;
        [FieldOffset(144)] internal FixedBytes16 offset0144;
        [FieldOffset(160)] internal FixedBytes16 offset0160;
        [FieldOffset(176)] internal FixedBytes16 offset0176;
        [FieldOffset(192)] internal FixedBytes16 offset0192;
        [FieldOffset(208)] internal FixedBytes16 offset0208;
        [FieldOffset(224)] internal FixedBytes16 offset0224;
        [FieldOffset(240)] internal FixedBytes16 offset0240;
        [FieldOffset(256)] internal FixedBytes16 offset0256;
        [FieldOffset(272)] internal FixedBytes16 offset0272;
        [FieldOffset(288)] internal FixedBytes16 offset0288;
        [FieldOffset(304)] internal FixedBytes16 offset0304;
        [FieldOffset(320)] internal FixedBytes16 offset0320;
        [FieldOffset(336)] internal FixedBytes16 offset0336;
        [FieldOffset(352)] internal FixedBytes16 offset0352;
        [FieldOffset(368)] internal FixedBytes16 offset0368;
        [FieldOffset(384)] internal FixedBytes16 offset0384;
        [FieldOffset(400)] internal FixedBytes16 offset0400;
        [FieldOffset(416)] internal FixedBytes16 offset0416;
        [FieldOffset(432)] internal FixedBytes16 offset0432;
        [FieldOffset(448)] internal FixedBytes16 offset0448;
        [FieldOffset(464)] internal FixedBytes16 offset0464;
        [FieldOffset(480)] internal FixedBytes16 offset0480;
        [FieldOffset(496)] internal byte byte0496;
        [FieldOffset(497)] internal byte byte0497;
        [FieldOffset(498)] internal byte byte0498;
        [FieldOffset(499)] internal byte byte0499;
        [FieldOffset(500)] internal byte byte0500;
        [FieldOffset(501)] internal byte byte0501;
        [FieldOffset(502)] internal byte byte0502;
        [FieldOffset(503)] internal byte byte0503;
        [FieldOffset(504)] internal byte byte0504;
        [FieldOffset(505)] internal byte byte0505;
        [FieldOffset(506)] internal byte byte0506;
        [FieldOffset(507)] internal byte byte0507;
        [FieldOffset(508)] internal byte byte0508;
        [FieldOffset(509)] internal byte byte0509;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 512)]
    public struct FixedString512
        : INativeList<byte>
        , IComparable<String>
        , IEquatable<String>
        , IEquatable<FixedString32>
        , IEquatable<FixedString64>
        , IEquatable<FixedString128>
        , IEquatable<FixedString512>
        , IEquatable<FixedString4096>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes510 bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString512 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString512 of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes510* b = &bytes)
                    return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes510* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes510* b = &bytes)
                return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = 510;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString512 as a FixedListByte512, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte512 AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString512* t = &this)
                    return ref UnsafeUtilityEx.AsRef<FixedListByte512>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString512&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString512, at the byte offset indicated from the beginning
        /// of the FixedString512.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString512, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString512.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString512</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString512.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString512</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString512.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString512</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString512 that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString512(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for (var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if (error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString512 that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString512(char c, int count)
            : this(new Unicode.Rune {value = c}, count)
        {
        }

        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString32 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString32 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString32 onto this FixedString512.
        /// </summary>
        /// <param name="source">The 32 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int IndexOf(in FixedString32 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int LastIndexOf(in FixedString32 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return whether the FixedString32 was found or not.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <returns>
        /// true if the FixedString32 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString32 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString32 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString32 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString32 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString512 a, in FixedString32 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString32 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString512 a, in FixedString32 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString512 from a FixedString32
        /// </summary>
        /// <param name="source">The 32 to construct this string from</param>
        public FixedString512(in FixedString32 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString32 to FixedString512.
        /// </summary>
        /// <param name="b">The FixedString32 object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString32 source) => new FixedString512(source);


        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString64 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString64 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString64 onto this FixedString512.
        /// </summary>
        /// <param name="source">The 64 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int IndexOf(in FixedString64 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int LastIndexOf(in FixedString64 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return whether the FixedString64 was found or not.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <returns>
        /// true if the FixedString64 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString64 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString64 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString64 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString64 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString512 a, in FixedString64 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString64 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString512 a, in FixedString64 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString512 from a FixedString64
        /// </summary>
        /// <param name="source">The 64 to construct this string from</param>
        public FixedString512(in FixedString64 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString64 to FixedString512.
        /// </summary>
        /// <param name="b">The FixedString64 object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString64 source) => new FixedString512(source);


        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString128 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString128 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString128 onto this FixedString512.
        /// </summary>
        /// <param name="source">The 128 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int IndexOf(in FixedString128 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int LastIndexOf(in FixedString128 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return whether the FixedString128 was found or not.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <returns>
        /// true if the FixedString128 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString128 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString128 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString128 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString128 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString512 a, in FixedString128 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString128 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString512 a, in FixedString128 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString512 from a FixedString128
        /// </summary>
        /// <param name="source">The 128 to construct this string from</param>
        public FixedString512(in FixedString128 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString128 to FixedString512.
        /// </summary>
        /// <param name="b">The FixedString128 object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString128 source) => new FixedString512(source);


        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString512 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString512 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString512 onto this FixedString512.
        /// </summary>
        /// <param name="source">The 512 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int IndexOf(in FixedString512 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int LastIndexOf(in FixedString512 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return whether the FixedString512 was found or not.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <returns>
        /// true if the FixedString512 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString512 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString512 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString512 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString512 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString512 a, in FixedString512 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString512 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString512 a, in FixedString512 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Overwrite the contents of this FixedString512 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString4096 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString512.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString4096 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString4096 onto this FixedString512.
        /// </summary>
        /// <param name="source">The 4096 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int IndexOf(in FixedString4096 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int LastIndexOf(in FixedString4096 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return whether the FixedString4096 was found or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <returns>
        /// true if the FixedString4096 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString4096 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString4096 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString512 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString4096 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString4096 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString512 a, in FixedString4096 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString512 and FixedString4096 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString512 a, in FixedString4096 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString512 from a FixedString4096
        /// </summary>
        /// <param name="source">The 4096 to construct this string from</param>
        public FixedString512(in FixedString4096 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString4096 to FixedString512.
        /// </summary>
        /// <param name="b">The FixedString4096 object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(in FixedString4096 source) => new FixedString512(source);


        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString512 target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString512 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if (offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                    Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString512 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString512 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString512 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString512.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString512.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString512.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString512 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString512 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString512 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString512 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString512 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString512 with</param>
        public FixedString512(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString512.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString512</param>
        /// <returns></returns>
        public static implicit operator FixedString512(string b) => new FixedString512(b);

        /// <summary>
        /// Convert this FixedString512 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString512</returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString512: an integer that is likely to be different for
        /// two FixedString512, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString512</returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString512 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj is String aString) return Equals(aString);
            if (obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if (obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if (obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if (obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if (obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 4094)]
    internal struct FixedBytes4094
    {
        [FieldOffset(0)] internal FixedBytes16 offset0000;
        [FieldOffset(16)] internal FixedBytes16 offset0016;
        [FieldOffset(32)] internal FixedBytes16 offset0032;
        [FieldOffset(48)] internal FixedBytes16 offset0048;
        [FieldOffset(64)] internal FixedBytes16 offset0064;
        [FieldOffset(80)] internal FixedBytes16 offset0080;
        [FieldOffset(96)] internal FixedBytes16 offset0096;
        [FieldOffset(112)] internal FixedBytes16 offset0112;
        [FieldOffset(128)] internal FixedBytes16 offset0128;
        [FieldOffset(144)] internal FixedBytes16 offset0144;
        [FieldOffset(160)] internal FixedBytes16 offset0160;
        [FieldOffset(176)] internal FixedBytes16 offset0176;
        [FieldOffset(192)] internal FixedBytes16 offset0192;
        [FieldOffset(208)] internal FixedBytes16 offset0208;
        [FieldOffset(224)] internal FixedBytes16 offset0224;
        [FieldOffset(240)] internal FixedBytes16 offset0240;
        [FieldOffset(256)] internal FixedBytes16 offset0256;
        [FieldOffset(272)] internal FixedBytes16 offset0272;
        [FieldOffset(288)] internal FixedBytes16 offset0288;
        [FieldOffset(304)] internal FixedBytes16 offset0304;
        [FieldOffset(320)] internal FixedBytes16 offset0320;
        [FieldOffset(336)] internal FixedBytes16 offset0336;
        [FieldOffset(352)] internal FixedBytes16 offset0352;
        [FieldOffset(368)] internal FixedBytes16 offset0368;
        [FieldOffset(384)] internal FixedBytes16 offset0384;
        [FieldOffset(400)] internal FixedBytes16 offset0400;
        [FieldOffset(416)] internal FixedBytes16 offset0416;
        [FieldOffset(432)] internal FixedBytes16 offset0432;
        [FieldOffset(448)] internal FixedBytes16 offset0448;
        [FieldOffset(464)] internal FixedBytes16 offset0464;
        [FieldOffset(480)] internal FixedBytes16 offset0480;
        [FieldOffset(496)] internal FixedBytes16 offset0496;
        [FieldOffset(512)] internal FixedBytes16 offset0512;
        [FieldOffset(528)] internal FixedBytes16 offset0528;
        [FieldOffset(544)] internal FixedBytes16 offset0544;
        [FieldOffset(560)] internal FixedBytes16 offset0560;
        [FieldOffset(576)] internal FixedBytes16 offset0576;
        [FieldOffset(592)] internal FixedBytes16 offset0592;
        [FieldOffset(608)] internal FixedBytes16 offset0608;
        [FieldOffset(624)] internal FixedBytes16 offset0624;
        [FieldOffset(640)] internal FixedBytes16 offset0640;
        [FieldOffset(656)] internal FixedBytes16 offset0656;
        [FieldOffset(672)] internal FixedBytes16 offset0672;
        [FieldOffset(688)] internal FixedBytes16 offset0688;
        [FieldOffset(704)] internal FixedBytes16 offset0704;
        [FieldOffset(720)] internal FixedBytes16 offset0720;
        [FieldOffset(736)] internal FixedBytes16 offset0736;
        [FieldOffset(752)] internal FixedBytes16 offset0752;
        [FieldOffset(768)] internal FixedBytes16 offset0768;
        [FieldOffset(784)] internal FixedBytes16 offset0784;
        [FieldOffset(800)] internal FixedBytes16 offset0800;
        [FieldOffset(816)] internal FixedBytes16 offset0816;
        [FieldOffset(832)] internal FixedBytes16 offset0832;
        [FieldOffset(848)] internal FixedBytes16 offset0848;
        [FieldOffset(864)] internal FixedBytes16 offset0864;
        [FieldOffset(880)] internal FixedBytes16 offset0880;
        [FieldOffset(896)] internal FixedBytes16 offset0896;
        [FieldOffset(912)] internal FixedBytes16 offset0912;
        [FieldOffset(928)] internal FixedBytes16 offset0928;
        [FieldOffset(944)] internal FixedBytes16 offset0944;
        [FieldOffset(960)] internal FixedBytes16 offset0960;
        [FieldOffset(976)] internal FixedBytes16 offset0976;
        [FieldOffset(992)] internal FixedBytes16 offset0992;
        [FieldOffset(1008)] internal FixedBytes16 offset1008;
        [FieldOffset(1024)] internal FixedBytes16 offset1024;
        [FieldOffset(1040)] internal FixedBytes16 offset1040;
        [FieldOffset(1056)] internal FixedBytes16 offset1056;
        [FieldOffset(1072)] internal FixedBytes16 offset1072;
        [FieldOffset(1088)] internal FixedBytes16 offset1088;
        [FieldOffset(1104)] internal FixedBytes16 offset1104;
        [FieldOffset(1120)] internal FixedBytes16 offset1120;
        [FieldOffset(1136)] internal FixedBytes16 offset1136;
        [FieldOffset(1152)] internal FixedBytes16 offset1152;
        [FieldOffset(1168)] internal FixedBytes16 offset1168;
        [FieldOffset(1184)] internal FixedBytes16 offset1184;
        [FieldOffset(1200)] internal FixedBytes16 offset1200;
        [FieldOffset(1216)] internal FixedBytes16 offset1216;
        [FieldOffset(1232)] internal FixedBytes16 offset1232;
        [FieldOffset(1248)] internal FixedBytes16 offset1248;
        [FieldOffset(1264)] internal FixedBytes16 offset1264;
        [FieldOffset(1280)] internal FixedBytes16 offset1280;
        [FieldOffset(1296)] internal FixedBytes16 offset1296;
        [FieldOffset(1312)] internal FixedBytes16 offset1312;
        [FieldOffset(1328)] internal FixedBytes16 offset1328;
        [FieldOffset(1344)] internal FixedBytes16 offset1344;
        [FieldOffset(1360)] internal FixedBytes16 offset1360;
        [FieldOffset(1376)] internal FixedBytes16 offset1376;
        [FieldOffset(1392)] internal FixedBytes16 offset1392;
        [FieldOffset(1408)] internal FixedBytes16 offset1408;
        [FieldOffset(1424)] internal FixedBytes16 offset1424;
        [FieldOffset(1440)] internal FixedBytes16 offset1440;
        [FieldOffset(1456)] internal FixedBytes16 offset1456;
        [FieldOffset(1472)] internal FixedBytes16 offset1472;
        [FieldOffset(1488)] internal FixedBytes16 offset1488;
        [FieldOffset(1504)] internal FixedBytes16 offset1504;
        [FieldOffset(1520)] internal FixedBytes16 offset1520;
        [FieldOffset(1536)] internal FixedBytes16 offset1536;
        [FieldOffset(1552)] internal FixedBytes16 offset1552;
        [FieldOffset(1568)] internal FixedBytes16 offset1568;
        [FieldOffset(1584)] internal FixedBytes16 offset1584;
        [FieldOffset(1600)] internal FixedBytes16 offset1600;
        [FieldOffset(1616)] internal FixedBytes16 offset1616;
        [FieldOffset(1632)] internal FixedBytes16 offset1632;
        [FieldOffset(1648)] internal FixedBytes16 offset1648;
        [FieldOffset(1664)] internal FixedBytes16 offset1664;
        [FieldOffset(1680)] internal FixedBytes16 offset1680;
        [FieldOffset(1696)] internal FixedBytes16 offset1696;
        [FieldOffset(1712)] internal FixedBytes16 offset1712;
        [FieldOffset(1728)] internal FixedBytes16 offset1728;
        [FieldOffset(1744)] internal FixedBytes16 offset1744;
        [FieldOffset(1760)] internal FixedBytes16 offset1760;
        [FieldOffset(1776)] internal FixedBytes16 offset1776;
        [FieldOffset(1792)] internal FixedBytes16 offset1792;
        [FieldOffset(1808)] internal FixedBytes16 offset1808;
        [FieldOffset(1824)] internal FixedBytes16 offset1824;
        [FieldOffset(1840)] internal FixedBytes16 offset1840;
        [FieldOffset(1856)] internal FixedBytes16 offset1856;
        [FieldOffset(1872)] internal FixedBytes16 offset1872;
        [FieldOffset(1888)] internal FixedBytes16 offset1888;
        [FieldOffset(1904)] internal FixedBytes16 offset1904;
        [FieldOffset(1920)] internal FixedBytes16 offset1920;
        [FieldOffset(1936)] internal FixedBytes16 offset1936;
        [FieldOffset(1952)] internal FixedBytes16 offset1952;
        [FieldOffset(1968)] internal FixedBytes16 offset1968;
        [FieldOffset(1984)] internal FixedBytes16 offset1984;
        [FieldOffset(2000)] internal FixedBytes16 offset2000;
        [FieldOffset(2016)] internal FixedBytes16 offset2016;
        [FieldOffset(2032)] internal FixedBytes16 offset2032;
        [FieldOffset(2048)] internal FixedBytes16 offset2048;
        [FieldOffset(2064)] internal FixedBytes16 offset2064;
        [FieldOffset(2080)] internal FixedBytes16 offset2080;
        [FieldOffset(2096)] internal FixedBytes16 offset2096;
        [FieldOffset(2112)] internal FixedBytes16 offset2112;
        [FieldOffset(2128)] internal FixedBytes16 offset2128;
        [FieldOffset(2144)] internal FixedBytes16 offset2144;
        [FieldOffset(2160)] internal FixedBytes16 offset2160;
        [FieldOffset(2176)] internal FixedBytes16 offset2176;
        [FieldOffset(2192)] internal FixedBytes16 offset2192;
        [FieldOffset(2208)] internal FixedBytes16 offset2208;
        [FieldOffset(2224)] internal FixedBytes16 offset2224;
        [FieldOffset(2240)] internal FixedBytes16 offset2240;
        [FieldOffset(2256)] internal FixedBytes16 offset2256;
        [FieldOffset(2272)] internal FixedBytes16 offset2272;
        [FieldOffset(2288)] internal FixedBytes16 offset2288;
        [FieldOffset(2304)] internal FixedBytes16 offset2304;
        [FieldOffset(2320)] internal FixedBytes16 offset2320;
        [FieldOffset(2336)] internal FixedBytes16 offset2336;
        [FieldOffset(2352)] internal FixedBytes16 offset2352;
        [FieldOffset(2368)] internal FixedBytes16 offset2368;
        [FieldOffset(2384)] internal FixedBytes16 offset2384;
        [FieldOffset(2400)] internal FixedBytes16 offset2400;
        [FieldOffset(2416)] internal FixedBytes16 offset2416;
        [FieldOffset(2432)] internal FixedBytes16 offset2432;
        [FieldOffset(2448)] internal FixedBytes16 offset2448;
        [FieldOffset(2464)] internal FixedBytes16 offset2464;
        [FieldOffset(2480)] internal FixedBytes16 offset2480;
        [FieldOffset(2496)] internal FixedBytes16 offset2496;
        [FieldOffset(2512)] internal FixedBytes16 offset2512;
        [FieldOffset(2528)] internal FixedBytes16 offset2528;
        [FieldOffset(2544)] internal FixedBytes16 offset2544;
        [FieldOffset(2560)] internal FixedBytes16 offset2560;
        [FieldOffset(2576)] internal FixedBytes16 offset2576;
        [FieldOffset(2592)] internal FixedBytes16 offset2592;
        [FieldOffset(2608)] internal FixedBytes16 offset2608;
        [FieldOffset(2624)] internal FixedBytes16 offset2624;
        [FieldOffset(2640)] internal FixedBytes16 offset2640;
        [FieldOffset(2656)] internal FixedBytes16 offset2656;
        [FieldOffset(2672)] internal FixedBytes16 offset2672;
        [FieldOffset(2688)] internal FixedBytes16 offset2688;
        [FieldOffset(2704)] internal FixedBytes16 offset2704;
        [FieldOffset(2720)] internal FixedBytes16 offset2720;
        [FieldOffset(2736)] internal FixedBytes16 offset2736;
        [FieldOffset(2752)] internal FixedBytes16 offset2752;
        [FieldOffset(2768)] internal FixedBytes16 offset2768;
        [FieldOffset(2784)] internal FixedBytes16 offset2784;
        [FieldOffset(2800)] internal FixedBytes16 offset2800;
        [FieldOffset(2816)] internal FixedBytes16 offset2816;
        [FieldOffset(2832)] internal FixedBytes16 offset2832;
        [FieldOffset(2848)] internal FixedBytes16 offset2848;
        [FieldOffset(2864)] internal FixedBytes16 offset2864;
        [FieldOffset(2880)] internal FixedBytes16 offset2880;
        [FieldOffset(2896)] internal FixedBytes16 offset2896;
        [FieldOffset(2912)] internal FixedBytes16 offset2912;
        [FieldOffset(2928)] internal FixedBytes16 offset2928;
        [FieldOffset(2944)] internal FixedBytes16 offset2944;
        [FieldOffset(2960)] internal FixedBytes16 offset2960;
        [FieldOffset(2976)] internal FixedBytes16 offset2976;
        [FieldOffset(2992)] internal FixedBytes16 offset2992;
        [FieldOffset(3008)] internal FixedBytes16 offset3008;
        [FieldOffset(3024)] internal FixedBytes16 offset3024;
        [FieldOffset(3040)] internal FixedBytes16 offset3040;
        [FieldOffset(3056)] internal FixedBytes16 offset3056;
        [FieldOffset(3072)] internal FixedBytes16 offset3072;
        [FieldOffset(3088)] internal FixedBytes16 offset3088;
        [FieldOffset(3104)] internal FixedBytes16 offset3104;
        [FieldOffset(3120)] internal FixedBytes16 offset3120;
        [FieldOffset(3136)] internal FixedBytes16 offset3136;
        [FieldOffset(3152)] internal FixedBytes16 offset3152;
        [FieldOffset(3168)] internal FixedBytes16 offset3168;
        [FieldOffset(3184)] internal FixedBytes16 offset3184;
        [FieldOffset(3200)] internal FixedBytes16 offset3200;
        [FieldOffset(3216)] internal FixedBytes16 offset3216;
        [FieldOffset(3232)] internal FixedBytes16 offset3232;
        [FieldOffset(3248)] internal FixedBytes16 offset3248;
        [FieldOffset(3264)] internal FixedBytes16 offset3264;
        [FieldOffset(3280)] internal FixedBytes16 offset3280;
        [FieldOffset(3296)] internal FixedBytes16 offset3296;
        [FieldOffset(3312)] internal FixedBytes16 offset3312;
        [FieldOffset(3328)] internal FixedBytes16 offset3328;
        [FieldOffset(3344)] internal FixedBytes16 offset3344;
        [FieldOffset(3360)] internal FixedBytes16 offset3360;
        [FieldOffset(3376)] internal FixedBytes16 offset3376;
        [FieldOffset(3392)] internal FixedBytes16 offset3392;
        [FieldOffset(3408)] internal FixedBytes16 offset3408;
        [FieldOffset(3424)] internal FixedBytes16 offset3424;
        [FieldOffset(3440)] internal FixedBytes16 offset3440;
        [FieldOffset(3456)] internal FixedBytes16 offset3456;
        [FieldOffset(3472)] internal FixedBytes16 offset3472;
        [FieldOffset(3488)] internal FixedBytes16 offset3488;
        [FieldOffset(3504)] internal FixedBytes16 offset3504;
        [FieldOffset(3520)] internal FixedBytes16 offset3520;
        [FieldOffset(3536)] internal FixedBytes16 offset3536;
        [FieldOffset(3552)] internal FixedBytes16 offset3552;
        [FieldOffset(3568)] internal FixedBytes16 offset3568;
        [FieldOffset(3584)] internal FixedBytes16 offset3584;
        [FieldOffset(3600)] internal FixedBytes16 offset3600;
        [FieldOffset(3616)] internal FixedBytes16 offset3616;
        [FieldOffset(3632)] internal FixedBytes16 offset3632;
        [FieldOffset(3648)] internal FixedBytes16 offset3648;
        [FieldOffset(3664)] internal FixedBytes16 offset3664;
        [FieldOffset(3680)] internal FixedBytes16 offset3680;
        [FieldOffset(3696)] internal FixedBytes16 offset3696;
        [FieldOffset(3712)] internal FixedBytes16 offset3712;
        [FieldOffset(3728)] internal FixedBytes16 offset3728;
        [FieldOffset(3744)] internal FixedBytes16 offset3744;
        [FieldOffset(3760)] internal FixedBytes16 offset3760;
        [FieldOffset(3776)] internal FixedBytes16 offset3776;
        [FieldOffset(3792)] internal FixedBytes16 offset3792;
        [FieldOffset(3808)] internal FixedBytes16 offset3808;
        [FieldOffset(3824)] internal FixedBytes16 offset3824;
        [FieldOffset(3840)] internal FixedBytes16 offset3840;
        [FieldOffset(3856)] internal FixedBytes16 offset3856;
        [FieldOffset(3872)] internal FixedBytes16 offset3872;
        [FieldOffset(3888)] internal FixedBytes16 offset3888;
        [FieldOffset(3904)] internal FixedBytes16 offset3904;
        [FieldOffset(3920)] internal FixedBytes16 offset3920;
        [FieldOffset(3936)] internal FixedBytes16 offset3936;
        [FieldOffset(3952)] internal FixedBytes16 offset3952;
        [FieldOffset(3968)] internal FixedBytes16 offset3968;
        [FieldOffset(3984)] internal FixedBytes16 offset3984;
        [FieldOffset(4000)] internal FixedBytes16 offset4000;
        [FieldOffset(4016)] internal FixedBytes16 offset4016;
        [FieldOffset(4032)] internal FixedBytes16 offset4032;
        [FieldOffset(4048)] internal FixedBytes16 offset4048;
        [FieldOffset(4064)] internal FixedBytes16 offset4064;
        [FieldOffset(4080)] internal byte byte4080;
        [FieldOffset(4081)] internal byte byte4081;
        [FieldOffset(4082)] internal byte byte4082;
        [FieldOffset(4083)] internal byte byte4083;
        [FieldOffset(4084)] internal byte byte4084;
        [FieldOffset(4085)] internal byte byte4085;
        [FieldOffset(4086)] internal byte byte4086;
        [FieldOffset(4087)] internal byte byte4087;
        [FieldOffset(4088)] internal byte byte4088;
        [FieldOffset(4089)] internal byte byte4089;
        [FieldOffset(4090)] internal byte byte4090;
        [FieldOffset(4091)] internal byte byte4091;
        [FieldOffset(4092)] internal byte byte4092;
        [FieldOffset(4093)] internal byte byte4093;
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size = 4096)]
    public struct FixedString4096
        : INativeList<byte>
        , IComparable<String>
        , IEquatable<String>
        , IEquatable<FixedString32>
        , IEquatable<FixedString64>
        , IEquatable<FixedString128>
        , IEquatable<FixedString512>
        , IEquatable<FixedString4096>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes4094 bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString4096 of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString4096 of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if (capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes4094* b = &bytes)
                    return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes4094* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes4094* b = &bytes)
                return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = 4094;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString4096 as a FixedListByte4096, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte4096 AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString4096* t = &this)
                    return ref UnsafeUtilityEx.AsRef<FixedListByte4096>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString4096&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString4096, at the byte offset indicated from the beginning
        /// of the FixedString4096.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString4096, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString4096.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString4096</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString4096.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString4096</param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString4096.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString4096</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString4096 that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString4096(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for (var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if (error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString4096 that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString4096(char c, int count)
            : this(new Unicode.Rune {value = c}, count)
        {
        }

        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString32 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString32 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 32 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString32 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString32 onto this FixedString4096.
        /// </summary>
        /// <param name="source">The 32 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString32 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int IndexOf(in FixedString32 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString32,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString32 was not found.
        /// otherwise, the index of the first occurrence of the FixedString32
        /// </returns>
        public int LastIndexOf(in FixedString32 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString32,
        /// and return whether the FixedString32 was found or not.
        /// </summary>
        /// <param name="other">The FixedString32 to search for</param>
        /// <returns>
        /// true if the FixedString32 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString32 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString32 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString32,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString32 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString32 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString32 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString4096 a, in FixedString32 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString32 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString4096 a, in FixedString32 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString4096 from a FixedString32
        /// </summary>
        /// <param name="source">The 32 to construct this string from</param>
        public FixedString4096(in FixedString32 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString32 to FixedString4096.
        /// </summary>
        /// <param name="b">The FixedString32 object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString32 source) => new FixedString4096(source);


        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString64 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString64 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 64 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString64 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString64 onto this FixedString4096.
        /// </summary>
        /// <param name="source">The 64 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString64 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int IndexOf(in FixedString64 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString64,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString64 was not found.
        /// otherwise, the index of the first occurrence of the FixedString64
        /// </returns>
        public int LastIndexOf(in FixedString64 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString64,
        /// and return whether the FixedString64 was found or not.
        /// </summary>
        /// <param name="other">The FixedString64 to search for</param>
        /// <returns>
        /// true if the FixedString64 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString64 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString64 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString64,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString64 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString64 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString64 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString4096 a, in FixedString64 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString64 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString4096 a, in FixedString64 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString4096 from a FixedString64
        /// </summary>
        /// <param name="source">The 64 to construct this string from</param>
        public FixedString4096(in FixedString64 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString64 to FixedString4096.
        /// </summary>
        /// <param name="b">The FixedString64 object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString64 source) => new FixedString4096(source);


        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString128 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString128 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 128 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString128 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString128 onto this FixedString4096.
        /// </summary>
        /// <param name="source">The 128 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString128 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int IndexOf(in FixedString128 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString128,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString128 was not found.
        /// otherwise, the index of the first occurrence of the FixedString128
        /// </returns>
        public int LastIndexOf(in FixedString128 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString128,
        /// and return whether the FixedString128 was found or not.
        /// </summary>
        /// <param name="other">The FixedString128 to search for</param>
        /// <returns>
        /// true if the FixedString128 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString128 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString128 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString128,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString128 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString128 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString128 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString4096 a, in FixedString128 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString128 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString4096 a, in FixedString128 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString4096 from a FixedString128
        /// </summary>
        /// <param name="source">The 128 to construct this string from</param>
        public FixedString4096(in FixedString128 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString128 to FixedString4096.
        /// </summary>
        /// <param name="b">The FixedString128 object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString128 source) => new FixedString4096(source);


        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString512 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString512 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 512 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString512 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString512 onto this FixedString4096.
        /// </summary>
        /// <param name="source">The 512 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString512 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int IndexOf(in FixedString512 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString512,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString512 was not found.
        /// otherwise, the index of the first occurrence of the FixedString512
        /// </returns>
        public int LastIndexOf(in FixedString512 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString512,
        /// and return whether the FixedString512 was found or not.
        /// </summary>
        /// <param name="other">The FixedString512 to search for</param>
        /// <returns>
        /// true if the FixedString512 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString512 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString512 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString512,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString512 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString512 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString512 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString4096 a, in FixedString512 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString512 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString4096 a, in FixedString512 b)
        {
            return !a.EqualsIn(b);
        }

        /// <summary>
        /// Construct a FixedString4096 from a FixedString512
        /// </summary>
        /// <param name="source">The 512 to construct this string from</param>
        public FixedString4096(in FixedString512 source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString512 to FixedString4096.
        /// </summary>
        /// <param name="b">The FixedString512 object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(in FixedString512 source) => new FixedString4096(source);


        /// <summary>
        /// Overwrite the contents of this FixedString4096 with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString4096 input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString4096 to the end of this FixedString4096.
        /// </summary>
        /// <param name="source">The 4096 to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString4096 source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString4096 onto this FixedString4096.
        /// </summary>
        /// <param name="source">The 4096 to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString4096 source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int IndexOf(in FixedString4096 other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString4096,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString4096 was not found.
        /// otherwise, the index of the first occurrence of the FixedString4096
        /// </returns>
        public int LastIndexOf(in FixedString4096 other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if (startIndex >= utf8LengthInBytes)
                return -1;
            if (startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if (startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString4096,
        /// and return whether the FixedString4096 was found or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to search for</param>
        /// <returns>
        /// true if the FixedString4096 was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString4096 other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString4096 other)
        {
            unsafe
            {
                fixed(byte* a = &bytes.offset0000.byte0000)
                fixed(byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString4096 with a FixedString4096,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString4096 to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString4096 other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString4096 have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator==(in FixedString4096 a, in FixedString4096 b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a FixedString4096 and FixedString4096 have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator!=(in FixedString4096 a, in FixedString4096 b)
        {
            return !a.EqualsIn(b);
        }

        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString4096 target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString4096 other)
            {
                target = other;
                offset = 0;
                current = default;
            }

            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if (offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                    Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes - 1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString4096 with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString4096 would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString4096 with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString4096.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString4096.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString4096.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString4096 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString4096 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString4096 into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString4096 into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
            return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString4096 from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString4096 with</param>
        public FixedString4096(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"FixedString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString4096.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString4096</param>
        /// <returns></returns>
        public static implicit operator FixedString4096(string b) => new FixedString4096(b);

        /// <summary>
        /// Convert this FixedString4096 to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString4096</returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString4096: an integer that is likely to be different for
        /// two FixedString4096, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString4096</returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString4096 has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj is String aString) return Equals(aString);
            if (obj is FixedString32 aFixedString32) return Equals(aFixedString32);
            if (obj is FixedString64 aFixedString64) return Equals(aFixedString64);
            if (obj is FixedString128 aFixedString128) return Equals(aFixedString128);
            if (obj is FixedString512 aFixedString512) return Equals(aFixedString512);
            if (obj is FixedString4096 aFixedString4096) return Equals(aFixedString4096);
            return false;
        }
    }
}
