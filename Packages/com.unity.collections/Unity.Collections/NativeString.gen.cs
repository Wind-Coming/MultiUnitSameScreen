//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/NativeString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// We have defined fixed-size NativeStrings, all of which are value types with zero allocation.
// You can copy them freely without ever generating garbage or needing to Dispose, but they are limited in size.
// If you want no size restrictions - if you want one type that works equally well for 1 character or 1,000,000,000 -
// you're better off using C#'s garbage-collected String type.
//
// NativeString32 - consumes 32 bytes of memory. suitable for short names. cacheline-sized on ARM
// NativeString64 - consumes 64 bytes of memory. suitable for names and descriptions. cacheline sized on non-ARM
// NativeString128 - consumes 128 bytes of memory. can hold a line of text.
// NativeString512 - consumes 512 bytes of memory.
// NativeString4096 - consumes 4096 bytes of memory. can hold a printed page of text.

using System;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Collections
{
    internal unsafe struct NativeString
    {
        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            var c = stackalloc char[Length * 2];
            int length = 0;
            Unicode.Utf8ToUtf16(data, Length, c, out length, Length * 2);
            return new String(c, 0, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return (int)CollectionHelper.Hash(data, Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="aa"></param>
        /// <param name="b"></param>
        /// <param name="bb"></param>
        /// <returns></returns>
        public static unsafe int CompareTo(byte *a, int aa, byte* b, int bb)
        {
            int chars = aa < bb ? aa : bb;
            for (var i = 0; i < chars; ++i)
            {
                if (a[i] < b[i])
                    return -1;
                if (a[i] > b[i])
                    return 1;
            }
            if (aa < bb)
                return -1;
            if (aa > bb)
                return 1;
            return 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="aa"></param>
        /// <param name="b"></param>
        /// <param name="bb"></param>
        /// <returns></returns>
        public static unsafe bool Equals(byte *a, int aa, byte* b, int bb)
        {
            if (aa != bb)
                return false;
            return UnsafeUtility.MemCmp(a, b, aa) == 0;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        public static bool IsDigit(Unicode.Rune c)
        {
            return c.value >= '0' && c.value <= '9';
        }

        /// <summary>
        /// </summary>
        public int Length;

        /// <summary>
        /// </summary>
        public int Capacity;

        /// <summary>
        /// </summary>
        public byte* data;

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <returns></returns>
        public Unicode.Rune Peek(int offset)
        {
            if (offset >= Length)
                return Unicode.BadRune;
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <returns></returns>
        public Unicode.Rune Read(ref int offset)
        {
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="rune"></param>
        public void Write(ref int offset, Unicode.Rune rune)
        {
            Unicode.UcsToUtf8(data, ref offset, Capacity, rune);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            long value = 0;
            int sign = 1;
            int digits = 0;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                value *= 10;
                value += Read(ref offset).value - '0';
                if (value >> 32 != 0)
                    return ParseError.Overflow;
                ++digits;
            }
            if (digits == 0)
                return ParseError.Syntax;
            value = sign * value;
            if (value > Int32.MaxValue)
                return ParseError.Overflow;
            if (value < Int32.MinValue)
                return ParseError.Overflow;
            output = (int)value;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        [StructLayout(LayoutKind.Explicit)]
        internal struct UintFloatUnion
        {
            [FieldOffset(0)]
            public uint uintValue;
            [FieldOffset(0)]
            public float floatValue;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="output"></param>
        /// <param name="mantissa10"></param>
        /// <param name="exponent10"></param>
        /// <returns></returns>
        static ParseError Base10ToBase2(ref float output, ulong mantissa10, int exponent10)
        {
            if (mantissa10 == 0)
            {
                output = 0.0f;
                return ParseError.None;
            }
            if (exponent10 == 0)
            {
                output = mantissa10;
                return ParseError.None;
            }
            var exponent2 = exponent10;
            var mantissa2 = mantissa10;
            while (exponent10 > 0)
            {
                while ((mantissa2 & 0xe000000000000000U) != 0)
                {
                    mantissa2 >>= 1;
                    ++exponent2;
                }
                mantissa2 *= 5;
                --exponent10;
            }
            while (exponent10 < 0)
            {
                while ((mantissa2 & 0x8000000000000000U) == 0)
                {
                    mantissa2 <<= 1;
                    --exponent2;
                }
                mantissa2 /= 5;
                ++exponent10;
            }
            // TODO: implement math.ldexpf (which presumably handles denormals (i don't))
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = mantissa2;
            var e = (int)((ufu.uintValue >> 23) & 0xFFU) - 127;
            e += exponent2;
            if (e > 128)
                return ParseError.Overflow;
            if (e < -127)
                return ParseError.Underflow;
            ufu.uintValue = (ufu.uintValue & ~(0xFFU << 23)) | ((uint)(e + 127) << 23);
            output = ufu.floatValue;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="mantissa10"></param>
        /// <param name="exponent10"></param>
        /// <param name="input"></param>
        public static void Base2ToBase10(ref ulong mantissa10, ref int exponent10, float input)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if (ufu.uintValue == 0)
            {
                mantissa10 = 0;
                exponent10 = 0;
                return;
            }
            var mantissa2 = (ufu.uintValue & ((1 << 23) - 1)) | (1 << 23);
            var exponent2 = (int)(ufu.uintValue >> 23) - 127 - 23;
            mantissa10 = mantissa2;
            exponent10 = exponent2;
            if (exponent2 > 0)
            {
                while (exponent2 > 0)
                {
                    // denormalize mantissa10 as much as you can, to minimize loss when doing /5 below.
                    while (mantissa10 <= UInt64.MaxValue / 10)
                    {
                        mantissa10 *= 10;
                        --exponent10;
                    }
                    mantissa10 /= 5;
                    --exponent2;
                }
            }
            if (exponent2 < 0)
            {
                while (exponent2 < 0)
                {
                    // normalize mantissa10 just as much as you need, in order to make the *5 below not overflow.
                    while (mantissa10 > UInt64.MaxValue / 5)
                    {
                        mantissa10 /= 10;
                        ++exponent10;
                    }
                    mantissa10 *= 5;
                    ++exponent2;
                }
            }
            // normalize mantissa10
            while (mantissa10 > 9999999U || mantissa10 % 10 == 0)
            {
                mantissa10 = (mantissa10 + 5) / 10;
                ++exponent10;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public FormatError Format(char a)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c, char d, char e, char f, char g, char h)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = d});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = e});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = f});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = g});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = h});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <param name="sourceLength"></param>
        /// <param name="decimalExponent"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError FormatScientific(char *source, int sourceLength, int decimalExponent, char decimalSeparator)
        {
            FormatError error;
            if ((error = Format(source[0])) != FormatError.None)
                return error;
            if (sourceLength > 1)
            {
                if ((error = Format(decimalSeparator)) != FormatError.None)
                    return error;
                for (var i = 1; i < sourceLength; ++i)
                {
                    if ((error = Format(source[i])) != FormatError.None)
                        return error;
                }
            }
            if ((error = Format('E')) != FormatError.None)
                return error;
            if (decimalExponent < 0)
            {
                if ((error = Format('-')) != FormatError.None)
                    return error;
                decimalExponent *= -1;
            }
            else if ((error = Format('+')) != FormatError.None)
                return error;
            var ascii = stackalloc char[2];
            decimalExponent -= sourceLength - 1;
            const int decimalDigits = 2;
            for (var i = 0; i < decimalDigits; ++i)
            {
                var decimalDigit = decimalExponent % 10;
                ascii[1 - i] = (char)('0' + decimalDigit);
                decimalExponent /= 10;
            }
            for (var i = 0; i < decimalDigits; ++i)
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            const int maximumDigits = 20;
            var temp = stackalloc byte[maximumDigits];
            int offset = maximumDigits;
            if (input >= 0)
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' + digit);
                    input /= 10;
                }
                while (input != 0);
            }
            else
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' - digit);
                    input /= 10;
                }
                while (input != 0);
                temp[--offset] = (byte)'-';
            }
            var newLength = maximumDigits - offset;
            if (newLength > Capacity)
                return FormatError.Overflow;
            Length = newLength;
            UnsafeUtility.MemCpy(data, temp + offset, Length);
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            return Format((long)input);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if (ufu.uintValue == 4290772992U)
                return Format('N', 'a', 'N');
            var sign = ufu.uintValue >> 31;
            ufu.uintValue &= ~(1 << 31);
            FormatError error;
            if (sign != 0 && ufu.uintValue != 0) // C# prints -0 as 0
                if ((error = Format('-')) != FormatError.None)
                    return error;
            if (ufu.uintValue == 2139095040U)
                return Format('I', 'n', 'f', 'i', 'n', 'i', 't', 'y');
            ulong decimalMantissa = 0;
            int decimalExponent = 0;
            Base2ToBase10(ref decimalMantissa, ref decimalExponent, ufu.floatValue);
            var backwards = stackalloc char[9];
            int decimalDigits = 0;
            do
            {
                if (decimalDigits >= 9)
                    return FormatError.Overflow;
                var decimalDigit = decimalMantissa % 10;
                backwards[8 - decimalDigits++] = (char)('0' + decimalDigit);
                decimalMantissa /= 10;
            }
            while (decimalMantissa > 0);
            char *ascii = backwards + 9 - decimalDigits;
            var leadingZeroes = -decimalExponent - decimalDigits + 1;
            if (leadingZeroes > 0)
            {
                if (leadingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                if ((error = Format('0', decimalSeparator)) != FormatError.None)
                    return error;
                --leadingZeroes;
                while (leadingZeroes > 0)
                {
                    if ((error = Format('0')) != FormatError.None)
                        return error;
                    --leadingZeroes;
                }
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format(ascii[i])) != FormatError.None)
                        return error;
                }
                return FormatError.None;
            }
            var trailingZeroes = decimalExponent;
            if (trailingZeroes > 0)
            {
                if (trailingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format(ascii[i])) != FormatError.None)
                        return error;
                }
                while (trailingZeroes > 0)
                {
                    if ((error = Format('0')) != FormatError.None)
                        return error;
                    --trailingZeroes;
                }
                return FormatError.None;
            }
            var indexOfSeparator = decimalDigits + decimalExponent;
            for (var i = 0; i < decimalDigits; ++i)
            {
                if (i == indexOfSeparator)
                    if ((error = Format(decimalSeparator)) != FormatError.None)
                        return error;
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            }
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c)
        {
            int old = offset;
            if ((Read(ref offset).value | 32) == a
                && (Read(ref offset).value | 32) == b
                && (Read(ref offset).value | 32) == c)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c, char d, char e, char f, char g, char h)
        {
            int old = offset;
            if ((Read(ref offset).value | 32) == a
                && (Read(ref offset).value | 32) == b
                && (Read(ref offset).value | 32) == c
                && (Read(ref offset).value | 32) == d
                && (Read(ref offset).value | 32) == e
                && (Read(ref offset).value | 32) == f
                && (Read(ref offset).value | 32) == g
                && (Read(ref offset).value | 32) == h)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator)
        {
            if (Found(ref offset, 'n', 'a', 'n'))
            {
                UintFloatUnion ufu = new UintFloatUnion();
                ufu.uintValue = 4290772992U;
                output = ufu.floatValue;
                return ParseError.None;
            }
            int sign = 1;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            ulong decimalMantissa = 0;
            int significantDigits = 0;
            int digitsAfterDot = 0;
            int mantissaDigits = 0;
            if (Found(ref offset, 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'))
            {
                output = (sign == 1) ? Single.PositiveInfinity : Single.NegativeInfinity;
                return ParseError.None;
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                ++mantissaDigits;
                if (significantDigits < 9)
                {
                    var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                    if (temp > decimalMantissa)
                        ++significantDigits;
                    decimalMantissa = temp;
                }
                else
                    --digitsAfterDot;
                Read(ref offset);
            }
            if (offset < Length && Peek(offset).value == decimalSeparator)
            {
                Read(ref offset);
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++mantissaDigits;
                    if (significantDigits < 9)
                    {
                        var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                        if (temp > decimalMantissa)
                            ++significantDigits;
                        decimalMantissa = temp;
                        ++digitsAfterDot;
                    }
                    Read(ref offset);
                }
            }
            if (mantissaDigits == 0)
                return ParseError.Syntax;
            int decimalExponent = 0;
            int decimalExponentSign = 1;
            if (offset < Length && (Peek(offset).value | 32) == 'e')
            {
                Read(ref offset);
                if (offset < Length)
                {
                    if (Peek(offset).value == '+')
                        Read(ref offset);
                    else if (Peek(offset).value == '-')
                    {
                        decimalExponentSign = -1;
                        Read(ref offset);
                    }
                }
                int exponentDigits = 0;
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++exponentDigits;
                    decimalExponent = decimalExponent * 10 + (Peek(offset).value - '0');
                    if (decimalExponent > 38)
                        if (decimalExponentSign == 1)
                            return ParseError.Overflow;
                        else
                            return ParseError.Underflow;
                    Read(ref offset);
                }
                if (exponentDigits == 0)
                    return ParseError.Syntax;
            }
            decimalExponent = decimalExponent * decimalExponentSign - digitsAfterDot;
            var error = Base10ToBase2(ref output, decimalMantissa, decimalExponent);
            if (error != ParseError.None)
                return error;
            output *= sign;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destMaxLength, char *src, int srcLength)
        {
            if (ConversionError.None == Unicode.Utf16ToUtf8(src, srcLength, dest, out destLength, destMaxLength))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destMaxLength, byte *src, int srcLength)
        {
            destLength = srcLength > destMaxLength ? destMaxLength : srcLength;
            UnsafeUtility.MemCpy(dest, src, destLength);
            return destLength == srcLength ? CopyError.None : CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out int destLength, int destMaxLength, byte *src, int srcLength)
        {
            if (ConversionError.None == Unicode.Utf8ToUtf16(src, srcLength, dest, out destLength, destMaxLength))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destMaxLength, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest, out var temp, destMaxLength);
            destLength = (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destMaxLength, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destMaxLength"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(char *dest, ref ushort destLength, ushort destMaxLength, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest + destLength, out var temp, destMaxLength - destLength);
            destLength += (ushort)temp;
            if (error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 1)]
    public struct Bytes1
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct Bytes16
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public byte byte0014;
        /// <summary>
        /// </summary>
        [FieldOffset(15)] public byte byte0015;
    }


    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 30)]
    public struct Bytes30
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public Bytes16 byte0014;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public struct NativeString32 : IComparable<NativeString32>, IEquatable<NativeString32>
    {
        public const int MaxLength = 30;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes30 buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes30* b = &buffer)
                return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString32 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString32 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString64 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString64 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString32(ref NativeString64 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString128 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString128 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString32(ref NativeString128 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString512 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString512 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString32(ref NativeString512 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString4096 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString4096 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString32(ref NativeString4096 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString32(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes30 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString32: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString32(string b) => new NativeString32(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString32 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString32 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString32 other && Equals(other);
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 62)]
    public struct Bytes62
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public Bytes16 byte0014;
        /// <summary>
        /// </summary>
        [FieldOffset(30)] public Bytes16 byte0030;
        /// <summary>
        /// </summary>
        [FieldOffset(46)] public Bytes16 byte0046;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public struct NativeString64 : IComparable<NativeString64>, IEquatable<NativeString64>
    {
        public const int MaxLength = 62;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes62 buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes62* b = &buffer)
                return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString32 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString32 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString64(ref NativeString32 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString64 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString64 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString128 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString128 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString64(ref NativeString128 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString512 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString512 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString64(ref NativeString512 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString4096 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString4096 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString64(ref NativeString4096 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString64(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes62 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString64: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString64(string b) => new NativeString64(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString64 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString64 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString64 other && Equals(other);
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 126)]
    public struct Bytes126
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public Bytes16 byte0014;
        /// <summary>
        /// </summary>
        [FieldOffset(30)] public Bytes16 byte0030;
        /// <summary>
        /// </summary>
        [FieldOffset(46)] public Bytes16 byte0046;
        /// <summary>
        /// </summary>
        [FieldOffset(62)] public Bytes16 byte0062;
        /// <summary>
        /// </summary>
        [FieldOffset(78)] public Bytes16 byte0078;
        /// <summary>
        /// </summary>
        [FieldOffset(94)] public Bytes16 byte0094;
        /// <summary>
        /// </summary>
        [FieldOffset(110)] public Bytes16 byte0110;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 128)]
    public struct NativeString128 : IComparable<NativeString128>, IEquatable<NativeString128>
    {
        public const int MaxLength = 126;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes126 buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes126* b = &buffer)
                return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString32 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString32 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString128(ref NativeString32 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString64 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString64 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString128(ref NativeString64 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString128 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString128 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString512 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString512 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString128(ref NativeString512 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString4096 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString4096 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString128(ref NativeString4096 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString128(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes126 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString128: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString128(string b) => new NativeString128(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString128 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString128 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString128 other && Equals(other);
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 510)]
    public struct Bytes510
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public Bytes16 byte0014;
        /// <summary>
        /// </summary>
        [FieldOffset(30)] public Bytes16 byte0030;
        /// <summary>
        /// </summary>
        [FieldOffset(46)] public Bytes16 byte0046;
        /// <summary>
        /// </summary>
        [FieldOffset(62)] public Bytes16 byte0062;
        /// <summary>
        /// </summary>
        [FieldOffset(78)] public Bytes16 byte0078;
        /// <summary>
        /// </summary>
        [FieldOffset(94)] public Bytes16 byte0094;
        /// <summary>
        /// </summary>
        [FieldOffset(110)] public Bytes16 byte0110;
        /// <summary>
        /// </summary>
        [FieldOffset(126)] public Bytes16 byte0126;
        /// <summary>
        /// </summary>
        [FieldOffset(142)] public Bytes16 byte0142;
        /// <summary>
        /// </summary>
        [FieldOffset(158)] public Bytes16 byte0158;
        /// <summary>
        /// </summary>
        [FieldOffset(174)] public Bytes16 byte0174;
        /// <summary>
        /// </summary>
        [FieldOffset(190)] public Bytes16 byte0190;
        /// <summary>
        /// </summary>
        [FieldOffset(206)] public Bytes16 byte0206;
        /// <summary>
        /// </summary>
        [FieldOffset(222)] public Bytes16 byte0222;
        /// <summary>
        /// </summary>
        [FieldOffset(238)] public Bytes16 byte0238;
        /// <summary>
        /// </summary>
        [FieldOffset(254)] public Bytes16 byte0254;
        /// <summary>
        /// </summary>
        [FieldOffset(270)] public Bytes16 byte0270;
        /// <summary>
        /// </summary>
        [FieldOffset(286)] public Bytes16 byte0286;
        /// <summary>
        /// </summary>
        [FieldOffset(302)] public Bytes16 byte0302;
        /// <summary>
        /// </summary>
        [FieldOffset(318)] public Bytes16 byte0318;
        /// <summary>
        /// </summary>
        [FieldOffset(334)] public Bytes16 byte0334;
        /// <summary>
        /// </summary>
        [FieldOffset(350)] public Bytes16 byte0350;
        /// <summary>
        /// </summary>
        [FieldOffset(366)] public Bytes16 byte0366;
        /// <summary>
        /// </summary>
        [FieldOffset(382)] public Bytes16 byte0382;
        /// <summary>
        /// </summary>
        [FieldOffset(398)] public Bytes16 byte0398;
        /// <summary>
        /// </summary>
        [FieldOffset(414)] public Bytes16 byte0414;
        /// <summary>
        /// </summary>
        [FieldOffset(430)] public Bytes16 byte0430;
        /// <summary>
        /// </summary>
        [FieldOffset(446)] public Bytes16 byte0446;
        /// <summary>
        /// </summary>
        [FieldOffset(462)] public Bytes16 byte0462;
        /// <summary>
        /// </summary>
        [FieldOffset(478)] public Bytes16 byte0478;
        /// <summary>
        /// </summary>
        [FieldOffset(494)] public Bytes16 byte0494;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 512)]
    public struct NativeString512 : IComparable<NativeString512>, IEquatable<NativeString512>
    {
        public const int MaxLength = 510;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes510 buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes510* b = &buffer)
                return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString32 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString32 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString512(ref NativeString32 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString64 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString64 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString512(ref NativeString64 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString128 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString128 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString512(ref NativeString128 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString512 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString512 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString4096 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString4096 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString512(ref NativeString4096 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString512(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes510 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString512: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString512(string b) => new NativeString512(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString512 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString512 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString512 other && Equals(other);
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 4094)]
    public struct Bytes4094
    {
        /// <summary>
        /// </summary>
        [FieldOffset(0)] public byte byte0000;
        /// <summary>
        /// </summary>
        [FieldOffset(1)] public byte byte0001;
        /// <summary>
        /// </summary>
        [FieldOffset(2)] public byte byte0002;
        /// <summary>
        /// </summary>
        [FieldOffset(3)] public byte byte0003;
        /// <summary>
        /// </summary>
        [FieldOffset(4)] public byte byte0004;
        /// <summary>
        /// </summary>
        [FieldOffset(5)] public byte byte0005;
        /// <summary>
        /// </summary>
        [FieldOffset(6)] public byte byte0006;
        /// <summary>
        /// </summary>
        [FieldOffset(7)] public byte byte0007;
        /// <summary>
        /// </summary>
        [FieldOffset(8)] public byte byte0008;
        /// <summary>
        /// </summary>
        [FieldOffset(9)] public byte byte0009;
        /// <summary>
        /// </summary>
        [FieldOffset(10)] public byte byte0010;
        /// <summary>
        /// </summary>
        [FieldOffset(11)] public byte byte0011;
        /// <summary>
        /// </summary>
        [FieldOffset(12)] public byte byte0012;
        /// <summary>
        /// </summary>
        [FieldOffset(13)] public byte byte0013;
        /// <summary>
        /// </summary>
        [FieldOffset(14)] public Bytes16 byte0014;
        /// <summary>
        /// </summary>
        [FieldOffset(30)] public Bytes16 byte0030;
        /// <summary>
        /// </summary>
        [FieldOffset(46)] public Bytes16 byte0046;
        /// <summary>
        /// </summary>
        [FieldOffset(62)] public Bytes16 byte0062;
        /// <summary>
        /// </summary>
        [FieldOffset(78)] public Bytes16 byte0078;
        /// <summary>
        /// </summary>
        [FieldOffset(94)] public Bytes16 byte0094;
        /// <summary>
        /// </summary>
        [FieldOffset(110)] public Bytes16 byte0110;
        /// <summary>
        /// </summary>
        [FieldOffset(126)] public Bytes16 byte0126;
        /// <summary>
        /// </summary>
        [FieldOffset(142)] public Bytes16 byte0142;
        /// <summary>
        /// </summary>
        [FieldOffset(158)] public Bytes16 byte0158;
        /// <summary>
        /// </summary>
        [FieldOffset(174)] public Bytes16 byte0174;
        /// <summary>
        /// </summary>
        [FieldOffset(190)] public Bytes16 byte0190;
        /// <summary>
        /// </summary>
        [FieldOffset(206)] public Bytes16 byte0206;
        /// <summary>
        /// </summary>
        [FieldOffset(222)] public Bytes16 byte0222;
        /// <summary>
        /// </summary>
        [FieldOffset(238)] public Bytes16 byte0238;
        /// <summary>
        /// </summary>
        [FieldOffset(254)] public Bytes16 byte0254;
        /// <summary>
        /// </summary>
        [FieldOffset(270)] public Bytes16 byte0270;
        /// <summary>
        /// </summary>
        [FieldOffset(286)] public Bytes16 byte0286;
        /// <summary>
        /// </summary>
        [FieldOffset(302)] public Bytes16 byte0302;
        /// <summary>
        /// </summary>
        [FieldOffset(318)] public Bytes16 byte0318;
        /// <summary>
        /// </summary>
        [FieldOffset(334)] public Bytes16 byte0334;
        /// <summary>
        /// </summary>
        [FieldOffset(350)] public Bytes16 byte0350;
        /// <summary>
        /// </summary>
        [FieldOffset(366)] public Bytes16 byte0366;
        /// <summary>
        /// </summary>
        [FieldOffset(382)] public Bytes16 byte0382;
        /// <summary>
        /// </summary>
        [FieldOffset(398)] public Bytes16 byte0398;
        /// <summary>
        /// </summary>
        [FieldOffset(414)] public Bytes16 byte0414;
        /// <summary>
        /// </summary>
        [FieldOffset(430)] public Bytes16 byte0430;
        /// <summary>
        /// </summary>
        [FieldOffset(446)] public Bytes16 byte0446;
        /// <summary>
        /// </summary>
        [FieldOffset(462)] public Bytes16 byte0462;
        /// <summary>
        /// </summary>
        [FieldOffset(478)] public Bytes16 byte0478;
        /// <summary>
        /// </summary>
        [FieldOffset(494)] public Bytes16 byte0494;
        /// <summary>
        /// </summary>
        [FieldOffset(510)] public Bytes16 byte0510;
        /// <summary>
        /// </summary>
        [FieldOffset(526)] public Bytes16 byte0526;
        /// <summary>
        /// </summary>
        [FieldOffset(542)] public Bytes16 byte0542;
        /// <summary>
        /// </summary>
        [FieldOffset(558)] public Bytes16 byte0558;
        /// <summary>
        /// </summary>
        [FieldOffset(574)] public Bytes16 byte0574;
        /// <summary>
        /// </summary>
        [FieldOffset(590)] public Bytes16 byte0590;
        /// <summary>
        /// </summary>
        [FieldOffset(606)] public Bytes16 byte0606;
        /// <summary>
        /// </summary>
        [FieldOffset(622)] public Bytes16 byte0622;
        /// <summary>
        /// </summary>
        [FieldOffset(638)] public Bytes16 byte0638;
        /// <summary>
        /// </summary>
        [FieldOffset(654)] public Bytes16 byte0654;
        /// <summary>
        /// </summary>
        [FieldOffset(670)] public Bytes16 byte0670;
        /// <summary>
        /// </summary>
        [FieldOffset(686)] public Bytes16 byte0686;
        /// <summary>
        /// </summary>
        [FieldOffset(702)] public Bytes16 byte0702;
        /// <summary>
        /// </summary>
        [FieldOffset(718)] public Bytes16 byte0718;
        /// <summary>
        /// </summary>
        [FieldOffset(734)] public Bytes16 byte0734;
        /// <summary>
        /// </summary>
        [FieldOffset(750)] public Bytes16 byte0750;
        /// <summary>
        /// </summary>
        [FieldOffset(766)] public Bytes16 byte0766;
        /// <summary>
        /// </summary>
        [FieldOffset(782)] public Bytes16 byte0782;
        /// <summary>
        /// </summary>
        [FieldOffset(798)] public Bytes16 byte0798;
        /// <summary>
        /// </summary>
        [FieldOffset(814)] public Bytes16 byte0814;
        /// <summary>
        /// </summary>
        [FieldOffset(830)] public Bytes16 byte0830;
        /// <summary>
        /// </summary>
        [FieldOffset(846)] public Bytes16 byte0846;
        /// <summary>
        /// </summary>
        [FieldOffset(862)] public Bytes16 byte0862;
        /// <summary>
        /// </summary>
        [FieldOffset(878)] public Bytes16 byte0878;
        /// <summary>
        /// </summary>
        [FieldOffset(894)] public Bytes16 byte0894;
        /// <summary>
        /// </summary>
        [FieldOffset(910)] public Bytes16 byte0910;
        /// <summary>
        /// </summary>
        [FieldOffset(926)] public Bytes16 byte0926;
        /// <summary>
        /// </summary>
        [FieldOffset(942)] public Bytes16 byte0942;
        /// <summary>
        /// </summary>
        [FieldOffset(958)] public Bytes16 byte0958;
        /// <summary>
        /// </summary>
        [FieldOffset(974)] public Bytes16 byte0974;
        /// <summary>
        /// </summary>
        [FieldOffset(990)] public Bytes16 byte0990;
        /// <summary>
        /// </summary>
        [FieldOffset(1006)] public Bytes16 byte1006;
        /// <summary>
        /// </summary>
        [FieldOffset(1022)] public Bytes16 byte1022;
        /// <summary>
        /// </summary>
        [FieldOffset(1038)] public Bytes16 byte1038;
        /// <summary>
        /// </summary>
        [FieldOffset(1054)] public Bytes16 byte1054;
        /// <summary>
        /// </summary>
        [FieldOffset(1070)] public Bytes16 byte1070;
        /// <summary>
        /// </summary>
        [FieldOffset(1086)] public Bytes16 byte1086;
        /// <summary>
        /// </summary>
        [FieldOffset(1102)] public Bytes16 byte1102;
        /// <summary>
        /// </summary>
        [FieldOffset(1118)] public Bytes16 byte1118;
        /// <summary>
        /// </summary>
        [FieldOffset(1134)] public Bytes16 byte1134;
        /// <summary>
        /// </summary>
        [FieldOffset(1150)] public Bytes16 byte1150;
        /// <summary>
        /// </summary>
        [FieldOffset(1166)] public Bytes16 byte1166;
        /// <summary>
        /// </summary>
        [FieldOffset(1182)] public Bytes16 byte1182;
        /// <summary>
        /// </summary>
        [FieldOffset(1198)] public Bytes16 byte1198;
        /// <summary>
        /// </summary>
        [FieldOffset(1214)] public Bytes16 byte1214;
        /// <summary>
        /// </summary>
        [FieldOffset(1230)] public Bytes16 byte1230;
        /// <summary>
        /// </summary>
        [FieldOffset(1246)] public Bytes16 byte1246;
        /// <summary>
        /// </summary>
        [FieldOffset(1262)] public Bytes16 byte1262;
        /// <summary>
        /// </summary>
        [FieldOffset(1278)] public Bytes16 byte1278;
        /// <summary>
        /// </summary>
        [FieldOffset(1294)] public Bytes16 byte1294;
        /// <summary>
        /// </summary>
        [FieldOffset(1310)] public Bytes16 byte1310;
        /// <summary>
        /// </summary>
        [FieldOffset(1326)] public Bytes16 byte1326;
        /// <summary>
        /// </summary>
        [FieldOffset(1342)] public Bytes16 byte1342;
        /// <summary>
        /// </summary>
        [FieldOffset(1358)] public Bytes16 byte1358;
        /// <summary>
        /// </summary>
        [FieldOffset(1374)] public Bytes16 byte1374;
        /// <summary>
        /// </summary>
        [FieldOffset(1390)] public Bytes16 byte1390;
        /// <summary>
        /// </summary>
        [FieldOffset(1406)] public Bytes16 byte1406;
        /// <summary>
        /// </summary>
        [FieldOffset(1422)] public Bytes16 byte1422;
        /// <summary>
        /// </summary>
        [FieldOffset(1438)] public Bytes16 byte1438;
        /// <summary>
        /// </summary>
        [FieldOffset(1454)] public Bytes16 byte1454;
        /// <summary>
        /// </summary>
        [FieldOffset(1470)] public Bytes16 byte1470;
        /// <summary>
        /// </summary>
        [FieldOffset(1486)] public Bytes16 byte1486;
        /// <summary>
        /// </summary>
        [FieldOffset(1502)] public Bytes16 byte1502;
        /// <summary>
        /// </summary>
        [FieldOffset(1518)] public Bytes16 byte1518;
        /// <summary>
        /// </summary>
        [FieldOffset(1534)] public Bytes16 byte1534;
        /// <summary>
        /// </summary>
        [FieldOffset(1550)] public Bytes16 byte1550;
        /// <summary>
        /// </summary>
        [FieldOffset(1566)] public Bytes16 byte1566;
        /// <summary>
        /// </summary>
        [FieldOffset(1582)] public Bytes16 byte1582;
        /// <summary>
        /// </summary>
        [FieldOffset(1598)] public Bytes16 byte1598;
        /// <summary>
        /// </summary>
        [FieldOffset(1614)] public Bytes16 byte1614;
        /// <summary>
        /// </summary>
        [FieldOffset(1630)] public Bytes16 byte1630;
        /// <summary>
        /// </summary>
        [FieldOffset(1646)] public Bytes16 byte1646;
        /// <summary>
        /// </summary>
        [FieldOffset(1662)] public Bytes16 byte1662;
        /// <summary>
        /// </summary>
        [FieldOffset(1678)] public Bytes16 byte1678;
        /// <summary>
        /// </summary>
        [FieldOffset(1694)] public Bytes16 byte1694;
        /// <summary>
        /// </summary>
        [FieldOffset(1710)] public Bytes16 byte1710;
        /// <summary>
        /// </summary>
        [FieldOffset(1726)] public Bytes16 byte1726;
        /// <summary>
        /// </summary>
        [FieldOffset(1742)] public Bytes16 byte1742;
        /// <summary>
        /// </summary>
        [FieldOffset(1758)] public Bytes16 byte1758;
        /// <summary>
        /// </summary>
        [FieldOffset(1774)] public Bytes16 byte1774;
        /// <summary>
        /// </summary>
        [FieldOffset(1790)] public Bytes16 byte1790;
        /// <summary>
        /// </summary>
        [FieldOffset(1806)] public Bytes16 byte1806;
        /// <summary>
        /// </summary>
        [FieldOffset(1822)] public Bytes16 byte1822;
        /// <summary>
        /// </summary>
        [FieldOffset(1838)] public Bytes16 byte1838;
        /// <summary>
        /// </summary>
        [FieldOffset(1854)] public Bytes16 byte1854;
        /// <summary>
        /// </summary>
        [FieldOffset(1870)] public Bytes16 byte1870;
        /// <summary>
        /// </summary>
        [FieldOffset(1886)] public Bytes16 byte1886;
        /// <summary>
        /// </summary>
        [FieldOffset(1902)] public Bytes16 byte1902;
        /// <summary>
        /// </summary>
        [FieldOffset(1918)] public Bytes16 byte1918;
        /// <summary>
        /// </summary>
        [FieldOffset(1934)] public Bytes16 byte1934;
        /// <summary>
        /// </summary>
        [FieldOffset(1950)] public Bytes16 byte1950;
        /// <summary>
        /// </summary>
        [FieldOffset(1966)] public Bytes16 byte1966;
        /// <summary>
        /// </summary>
        [FieldOffset(1982)] public Bytes16 byte1982;
        /// <summary>
        /// </summary>
        [FieldOffset(1998)] public Bytes16 byte1998;
        /// <summary>
        /// </summary>
        [FieldOffset(2014)] public Bytes16 byte2014;
        /// <summary>
        /// </summary>
        [FieldOffset(2030)] public Bytes16 byte2030;
        /// <summary>
        /// </summary>
        [FieldOffset(2046)] public Bytes16 byte2046;
        /// <summary>
        /// </summary>
        [FieldOffset(2062)] public Bytes16 byte2062;
        /// <summary>
        /// </summary>
        [FieldOffset(2078)] public Bytes16 byte2078;
        /// <summary>
        /// </summary>
        [FieldOffset(2094)] public Bytes16 byte2094;
        /// <summary>
        /// </summary>
        [FieldOffset(2110)] public Bytes16 byte2110;
        /// <summary>
        /// </summary>
        [FieldOffset(2126)] public Bytes16 byte2126;
        /// <summary>
        /// </summary>
        [FieldOffset(2142)] public Bytes16 byte2142;
        /// <summary>
        /// </summary>
        [FieldOffset(2158)] public Bytes16 byte2158;
        /// <summary>
        /// </summary>
        [FieldOffset(2174)] public Bytes16 byte2174;
        /// <summary>
        /// </summary>
        [FieldOffset(2190)] public Bytes16 byte2190;
        /// <summary>
        /// </summary>
        [FieldOffset(2206)] public Bytes16 byte2206;
        /// <summary>
        /// </summary>
        [FieldOffset(2222)] public Bytes16 byte2222;
        /// <summary>
        /// </summary>
        [FieldOffset(2238)] public Bytes16 byte2238;
        /// <summary>
        /// </summary>
        [FieldOffset(2254)] public Bytes16 byte2254;
        /// <summary>
        /// </summary>
        [FieldOffset(2270)] public Bytes16 byte2270;
        /// <summary>
        /// </summary>
        [FieldOffset(2286)] public Bytes16 byte2286;
        /// <summary>
        /// </summary>
        [FieldOffset(2302)] public Bytes16 byte2302;
        /// <summary>
        /// </summary>
        [FieldOffset(2318)] public Bytes16 byte2318;
        /// <summary>
        /// </summary>
        [FieldOffset(2334)] public Bytes16 byte2334;
        /// <summary>
        /// </summary>
        [FieldOffset(2350)] public Bytes16 byte2350;
        /// <summary>
        /// </summary>
        [FieldOffset(2366)] public Bytes16 byte2366;
        /// <summary>
        /// </summary>
        [FieldOffset(2382)] public Bytes16 byte2382;
        /// <summary>
        /// </summary>
        [FieldOffset(2398)] public Bytes16 byte2398;
        /// <summary>
        /// </summary>
        [FieldOffset(2414)] public Bytes16 byte2414;
        /// <summary>
        /// </summary>
        [FieldOffset(2430)] public Bytes16 byte2430;
        /// <summary>
        /// </summary>
        [FieldOffset(2446)] public Bytes16 byte2446;
        /// <summary>
        /// </summary>
        [FieldOffset(2462)] public Bytes16 byte2462;
        /// <summary>
        /// </summary>
        [FieldOffset(2478)] public Bytes16 byte2478;
        /// <summary>
        /// </summary>
        [FieldOffset(2494)] public Bytes16 byte2494;
        /// <summary>
        /// </summary>
        [FieldOffset(2510)] public Bytes16 byte2510;
        /// <summary>
        /// </summary>
        [FieldOffset(2526)] public Bytes16 byte2526;
        /// <summary>
        /// </summary>
        [FieldOffset(2542)] public Bytes16 byte2542;
        /// <summary>
        /// </summary>
        [FieldOffset(2558)] public Bytes16 byte2558;
        /// <summary>
        /// </summary>
        [FieldOffset(2574)] public Bytes16 byte2574;
        /// <summary>
        /// </summary>
        [FieldOffset(2590)] public Bytes16 byte2590;
        /// <summary>
        /// </summary>
        [FieldOffset(2606)] public Bytes16 byte2606;
        /// <summary>
        /// </summary>
        [FieldOffset(2622)] public Bytes16 byte2622;
        /// <summary>
        /// </summary>
        [FieldOffset(2638)] public Bytes16 byte2638;
        /// <summary>
        /// </summary>
        [FieldOffset(2654)] public Bytes16 byte2654;
        /// <summary>
        /// </summary>
        [FieldOffset(2670)] public Bytes16 byte2670;
        /// <summary>
        /// </summary>
        [FieldOffset(2686)] public Bytes16 byte2686;
        /// <summary>
        /// </summary>
        [FieldOffset(2702)] public Bytes16 byte2702;
        /// <summary>
        /// </summary>
        [FieldOffset(2718)] public Bytes16 byte2718;
        /// <summary>
        /// </summary>
        [FieldOffset(2734)] public Bytes16 byte2734;
        /// <summary>
        /// </summary>
        [FieldOffset(2750)] public Bytes16 byte2750;
        /// <summary>
        /// </summary>
        [FieldOffset(2766)] public Bytes16 byte2766;
        /// <summary>
        /// </summary>
        [FieldOffset(2782)] public Bytes16 byte2782;
        /// <summary>
        /// </summary>
        [FieldOffset(2798)] public Bytes16 byte2798;
        /// <summary>
        /// </summary>
        [FieldOffset(2814)] public Bytes16 byte2814;
        /// <summary>
        /// </summary>
        [FieldOffset(2830)] public Bytes16 byte2830;
        /// <summary>
        /// </summary>
        [FieldOffset(2846)] public Bytes16 byte2846;
        /// <summary>
        /// </summary>
        [FieldOffset(2862)] public Bytes16 byte2862;
        /// <summary>
        /// </summary>
        [FieldOffset(2878)] public Bytes16 byte2878;
        /// <summary>
        /// </summary>
        [FieldOffset(2894)] public Bytes16 byte2894;
        /// <summary>
        /// </summary>
        [FieldOffset(2910)] public Bytes16 byte2910;
        /// <summary>
        /// </summary>
        [FieldOffset(2926)] public Bytes16 byte2926;
        /// <summary>
        /// </summary>
        [FieldOffset(2942)] public Bytes16 byte2942;
        /// <summary>
        /// </summary>
        [FieldOffset(2958)] public Bytes16 byte2958;
        /// <summary>
        /// </summary>
        [FieldOffset(2974)] public Bytes16 byte2974;
        /// <summary>
        /// </summary>
        [FieldOffset(2990)] public Bytes16 byte2990;
        /// <summary>
        /// </summary>
        [FieldOffset(3006)] public Bytes16 byte3006;
        /// <summary>
        /// </summary>
        [FieldOffset(3022)] public Bytes16 byte3022;
        /// <summary>
        /// </summary>
        [FieldOffset(3038)] public Bytes16 byte3038;
        /// <summary>
        /// </summary>
        [FieldOffset(3054)] public Bytes16 byte3054;
        /// <summary>
        /// </summary>
        [FieldOffset(3070)] public Bytes16 byte3070;
        /// <summary>
        /// </summary>
        [FieldOffset(3086)] public Bytes16 byte3086;
        /// <summary>
        /// </summary>
        [FieldOffset(3102)] public Bytes16 byte3102;
        /// <summary>
        /// </summary>
        [FieldOffset(3118)] public Bytes16 byte3118;
        /// <summary>
        /// </summary>
        [FieldOffset(3134)] public Bytes16 byte3134;
        /// <summary>
        /// </summary>
        [FieldOffset(3150)] public Bytes16 byte3150;
        /// <summary>
        /// </summary>
        [FieldOffset(3166)] public Bytes16 byte3166;
        /// <summary>
        /// </summary>
        [FieldOffset(3182)] public Bytes16 byte3182;
        /// <summary>
        /// </summary>
        [FieldOffset(3198)] public Bytes16 byte3198;
        /// <summary>
        /// </summary>
        [FieldOffset(3214)] public Bytes16 byte3214;
        /// <summary>
        /// </summary>
        [FieldOffset(3230)] public Bytes16 byte3230;
        /// <summary>
        /// </summary>
        [FieldOffset(3246)] public Bytes16 byte3246;
        /// <summary>
        /// </summary>
        [FieldOffset(3262)] public Bytes16 byte3262;
        /// <summary>
        /// </summary>
        [FieldOffset(3278)] public Bytes16 byte3278;
        /// <summary>
        /// </summary>
        [FieldOffset(3294)] public Bytes16 byte3294;
        /// <summary>
        /// </summary>
        [FieldOffset(3310)] public Bytes16 byte3310;
        /// <summary>
        /// </summary>
        [FieldOffset(3326)] public Bytes16 byte3326;
        /// <summary>
        /// </summary>
        [FieldOffset(3342)] public Bytes16 byte3342;
        /// <summary>
        /// </summary>
        [FieldOffset(3358)] public Bytes16 byte3358;
        /// <summary>
        /// </summary>
        [FieldOffset(3374)] public Bytes16 byte3374;
        /// <summary>
        /// </summary>
        [FieldOffset(3390)] public Bytes16 byte3390;
        /// <summary>
        /// </summary>
        [FieldOffset(3406)] public Bytes16 byte3406;
        /// <summary>
        /// </summary>
        [FieldOffset(3422)] public Bytes16 byte3422;
        /// <summary>
        /// </summary>
        [FieldOffset(3438)] public Bytes16 byte3438;
        /// <summary>
        /// </summary>
        [FieldOffset(3454)] public Bytes16 byte3454;
        /// <summary>
        /// </summary>
        [FieldOffset(3470)] public Bytes16 byte3470;
        /// <summary>
        /// </summary>
        [FieldOffset(3486)] public Bytes16 byte3486;
        /// <summary>
        /// </summary>
        [FieldOffset(3502)] public Bytes16 byte3502;
        /// <summary>
        /// </summary>
        [FieldOffset(3518)] public Bytes16 byte3518;
        /// <summary>
        /// </summary>
        [FieldOffset(3534)] public Bytes16 byte3534;
        /// <summary>
        /// </summary>
        [FieldOffset(3550)] public Bytes16 byte3550;
        /// <summary>
        /// </summary>
        [FieldOffset(3566)] public Bytes16 byte3566;
        /// <summary>
        /// </summary>
        [FieldOffset(3582)] public Bytes16 byte3582;
        /// <summary>
        /// </summary>
        [FieldOffset(3598)] public Bytes16 byte3598;
        /// <summary>
        /// </summary>
        [FieldOffset(3614)] public Bytes16 byte3614;
        /// <summary>
        /// </summary>
        [FieldOffset(3630)] public Bytes16 byte3630;
        /// <summary>
        /// </summary>
        [FieldOffset(3646)] public Bytes16 byte3646;
        /// <summary>
        /// </summary>
        [FieldOffset(3662)] public Bytes16 byte3662;
        /// <summary>
        /// </summary>
        [FieldOffset(3678)] public Bytes16 byte3678;
        /// <summary>
        /// </summary>
        [FieldOffset(3694)] public Bytes16 byte3694;
        /// <summary>
        /// </summary>
        [FieldOffset(3710)] public Bytes16 byte3710;
        /// <summary>
        /// </summary>
        [FieldOffset(3726)] public Bytes16 byte3726;
        /// <summary>
        /// </summary>
        [FieldOffset(3742)] public Bytes16 byte3742;
        /// <summary>
        /// </summary>
        [FieldOffset(3758)] public Bytes16 byte3758;
        /// <summary>
        /// </summary>
        [FieldOffset(3774)] public Bytes16 byte3774;
        /// <summary>
        /// </summary>
        [FieldOffset(3790)] public Bytes16 byte3790;
        /// <summary>
        /// </summary>
        [FieldOffset(3806)] public Bytes16 byte3806;
        /// <summary>
        /// </summary>
        [FieldOffset(3822)] public Bytes16 byte3822;
        /// <summary>
        /// </summary>
        [FieldOffset(3838)] public Bytes16 byte3838;
        /// <summary>
        /// </summary>
        [FieldOffset(3854)] public Bytes16 byte3854;
        /// <summary>
        /// </summary>
        [FieldOffset(3870)] public Bytes16 byte3870;
        /// <summary>
        /// </summary>
        [FieldOffset(3886)] public Bytes16 byte3886;
        /// <summary>
        /// </summary>
        [FieldOffset(3902)] public Bytes16 byte3902;
        /// <summary>
        /// </summary>
        [FieldOffset(3918)] public Bytes16 byte3918;
        /// <summary>
        /// </summary>
        [FieldOffset(3934)] public Bytes16 byte3934;
        /// <summary>
        /// </summary>
        [FieldOffset(3950)] public Bytes16 byte3950;
        /// <summary>
        /// </summary>
        [FieldOffset(3966)] public Bytes16 byte3966;
        /// <summary>
        /// </summary>
        [FieldOffset(3982)] public Bytes16 byte3982;
        /// <summary>
        /// </summary>
        [FieldOffset(3998)] public Bytes16 byte3998;
        /// <summary>
        /// </summary>
        [FieldOffset(4014)] public Bytes16 byte4014;
        /// <summary>
        /// </summary>
        [FieldOffset(4030)] public Bytes16 byte4030;
        /// <summary>
        /// </summary>
        [FieldOffset(4046)] public Bytes16 byte4046;
        /// <summary>
        /// </summary>
        [FieldOffset(4062)] public Bytes16 byte4062;
        /// <summary>
        /// </summary>
        [FieldOffset(4078)] public Bytes16 byte4078;
    }

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Explicit, Size = 4096)]
    public struct NativeString4096 : IComparable<NativeString4096>, IEquatable<NativeString4096>
    {
        public const int MaxLength = 4094;
        [FieldOffset(0)] public ushort LengthInBytes;
        [FieldOffset(2)] public Bytes4094 buffer;

        /// <summary>
        /// When the length in bytes of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public int Utf8BufferLengthInBytes
        {
            get
            {
                return LengthInBytes;
            }
            set
            {
                LengthInBytes = (ushort)value;
            }
        }

        /// <summary>
        /// When the address of the UTF-8 buffer is needed, please use this property.
        /// </summary>
        public unsafe ref Bytes1 Utf8Buffer
        {
            get
            {
                fixed(Bytes4094* b = &buffer)
                return ref UnsafeUtilityEx.AsRef<Bytes1>(b);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    NativeString temp = new NativeString {data = b + LengthInBytes, Length = 0, Capacity = MaxLength - LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString32 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString32 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString4096(ref NativeString32 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString64 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString64 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString4096(ref NativeString64 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString128 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString128 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString4096(ref NativeString128 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString512 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString512 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        public NativeString4096(ref NativeString512 source)
        {
            LengthInBytes = 0;
            buffer = new Bytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError AppendFrom(NativeString4096 source)
        {
            fixed(byte * b = &buffer.byte0000)
            return source.AppendTo(b, ref LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(NativeString4096 source)
        {
            fixed(byte* b = &buffer.byte0000)
            return source.CopyTo(b, out LengthInBytes, MaxLength);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="s"></param>
        /// <param name="length"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(b, out LengthInBytes, MaxLength, s, length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
            return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Copy(d, out length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="d"></param>
        /// <param name="length"></param>
        /// <param name="maxLength"></param>
        /// <returns></returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed(byte* b = &buffer.byte0000)
            return NativeString.Append(d, ref length, maxLength, b, LengthInBytes);
        }

        /// <summary>
        ///
        /// </summary>
        public NativeString4096(String source)
        {
            LengthInBytes = 0;
            buffer = new Bytes4094 {};
            var error = CopyFrom(source);
            if (error != CopyError.None)
                throw new ArgumentException($"NativeString4096: {error} while copying \"{source}\"");
        }

        /// <summary>
        ///
        /// </summary>
        public static implicit operator NativeString4096(string b) => new NativeString4096(b);

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.ToString();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return new NativeString {data = b, Length = LengthInBytes, Capacity = MaxLength}.GetHashCode();
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public int CompareTo(NativeString4096 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.CompareTo(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(NativeString4096 other)
        {
            unsafe
            {
                fixed(byte* b = &buffer.byte0000)
                {
                    return NativeString.Equals(b, LengthInBytes, &other.buffer.byte0000, other.LengthInBytes);
                }
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            return obj is NativeString4096 other && Equals(other);
        }
    }
}
