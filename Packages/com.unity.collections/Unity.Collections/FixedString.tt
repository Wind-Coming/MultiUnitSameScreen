<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ template debug="True" #>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.collections/Unity.Collections/FixedString.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine.Internal;
using System.Diagnostics;

namespace Unity.Collections
{
    public struct FixedString
    {
        internal unsafe struct Formatter
        {
            public FixedString128 result;
            public FixedString128 *format;
            public FixedString32 arg0;
            public FixedString32 arg1;
            public FixedString32 arg2;
            public void Format()
            {
                ref var resultBytes = ref result.AsFixedList;
                ref var formatBytes = ref format->AsFixedList;
                for(var i = 0; i < formatBytes.Length; ++i)
                {
                    if(formatBytes[i] == '{')
                    {
                        if(formatBytes.Length - i >= 3 && formatBytes[i+1] != '{')
                        {
                            var index = formatBytes[i+1] - '0';
                            switch(index)
                            {
                                case 0: result.Append(arg0); i+=2; break;
                                case 1: result.Append(arg1); i+=2; break;
                                case 2: result.Append(arg2); i+=2; break;
                                default: resultBytes.Add(formatBytes[i]); break;
                            }
                        }
                    }
                    else
                        resultBytes.Add(formatBytes[i]);
                }
            }
        }
<#
{
    var TYPES = new string[] {"int", "float", "in FixedString32"};
    for(var arg0 = 0; arg0 < 3; ++arg0)
    {
        var t0 = TYPES[arg0];
#>

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a <#=t0#> argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type <#=t0#></param>
        /// <returns>A string, where the {} directives are replaced by the parameter a.</returns>
        public static FixedString128 Format(in FixedString128 format, <#=t0#> a)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }
<#
        for(var arg1 = 0; arg1 < 3; ++arg1)
        {
            var t1 = TYPES[arg1];
#>

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a <#=t0#> and <#=t1#> argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type <#=t0#></param>
        /// <param name="b">A parameter of type <#=t1#></param>
        /// <returns>A string, where the {} directives are replaced by the parameters a and b.</returns>
        public static FixedString128 Format(in FixedString128 format, <#=t0#> a, <#=t1#> b)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }
<#

            for(var arg2 = 0; arg2 < 3; ++arg2)
            {
                var t2 = TYPES[arg2];
#>

        /// <summary>
        /// Format a FixedString128 with the same interface you'd use to format a System.String.
        /// This variant takes a <#=t0#>, <#=t1#>, and <#=t2#> argument.
        /// </summary>
        /// <param name="format">A string, containing {} directives, in which parameters are inserted.</param>
        /// <param name="a">A parameter of type <#=t0#></param>
        /// <param name="b">A parameter of type <#=t1#></param>
        /// <param name="c">A parameter of type <#=t2#></param>
        /// <returns>A string, where the {} directives are replaced by the parameters a, b, and c.</returns>
        public static FixedString128 Format(in FixedString128 format, <#=t0#> a, <#=t1#> b, <#=t2#> c)
        {
            unsafe
            {
                fixed(FixedString128* f = &format)
                {
                    Formatter formatter = default;
                    formatter.format = f;
                    formatter.arg0.Format(a);
                    formatter.arg1.Format(b);
                    formatter.arg2.Format(c);
                    formatter.Format();
                    return formatter.result;
                }
            }
        }
<#
            }
        }
    }
}
#>
    }

    internal unsafe struct Generic
    {
        public override String ToString()
        {
            var c = stackalloc char[Length * 2];
            int length = 0;
            Unicode.Utf8ToUtf16(data, Length, c, out length, Length * 2);
            return new String(c, 0, length);
        }

        public override int GetHashCode()
        {
            return (int)CollectionHelper.Hash(data, Length);
        }

        public static unsafe int IndexOf(byte *a, int aa, byte* b, int bb)
        {
            for(var i = 0; i <= aa - bb; ++i)
            {
                for(var j = 0; j < bb; ++j)
                    if(a[i+j] != b[j])
                        goto end_of_loop;
                return i;
                end_of_loop: {}
            }
            return -1;
        }

        public static unsafe int LastIndexOf(byte *a, int aa, byte* b, int bb)
        {
            for(var i = aa - bb; i >= 0; --i)
            {
                for(var j = 0; j < bb; ++j)
                    if(a[i+j] != b[j])
                        goto end_of_loop;
                return i;
                end_of_loop: {}
            }
            return -1;
        }

        public static unsafe int CompareTo(byte *a, int aa, byte* b, int bb)
        {
            int chars = aa < bb ? aa : bb;
            for (var i = 0; i < chars; ++i)
            {
                if (a[i] < b[i])
                    return -1;
                if (a[i] > b[i])
                    return 1;
            }
            if (aa < bb)
                return -1;
            if (aa > bb)
                return 1;
            return 0;
        }

        public static unsafe bool Equals(byte *a, int aa, byte* b, int bb)
        {
            if(aa != bb)
                return false;
            if(a == b)
                return true;
            return CompareTo(a, aa, b, bb) == 0;
        }

        public static bool IsDigit(Unicode.Rune c)
        {
            return c.value >= '0' && c.value <= '9';
        }

        public int Length;
        public int Capacity;
        public byte* data;

        public Unicode.Rune Peek(int offset)
        {
            if (offset >= Length)
                return Unicode.BadRune;
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }
        public Unicode.Rune Read(ref int offset)
        {
            Unicode.Utf8ToUcs(out var rune, data, ref offset, Capacity);
            return rune;
        }

        public void Write(ref int offset, Unicode.Rune rune)
        {
            Unicode.UcsToUtf8(data, ref offset, Capacity, rune);
        }

        public ParseError Parse(ref int offset, ref int output)
        {
            long value = 0;
            int sign = 1;
            int digits = 0;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                value *= 10;
                value += Read(ref offset).value - '0';
                if(value >> 32 != 0)
                    return ParseError.Overflow;
                ++digits;
            }
            if (digits == 0)
                return ParseError.Syntax;
            value = sign * value;
            if(value > Int32.MaxValue)
                return ParseError.Overflow;
            if (value < Int32.MinValue)
                return ParseError.Overflow;
            output = (int)value;
            return ParseError.None;
        }

        [StructLayout(LayoutKind.Explicit)]
        internal struct UintFloatUnion
        {
            [FieldOffset(0)]
            public uint uintValue;
            [FieldOffset(0)]
            public float floatValue;
        }

        static ParseError Base10ToBase2(ref float output, ulong mantissa10, int exponent10)
        {
            if (mantissa10 == 0)
            {
                output = 0.0f;
                return ParseError.None;
            }
            if (exponent10 == 0)
            {
                output = mantissa10;
                return ParseError.None;
            }
            var exponent2 = exponent10;
            var mantissa2 = mantissa10;
            while (exponent10 > 0)
            {
                while ((mantissa2 & 0xe000000000000000U) != 0)
                {
                    mantissa2 >>= 1;
                    ++exponent2;
                }
                mantissa2 *= 5;
                --exponent10;
            }
            while(exponent10 < 0)
            {
                while ((mantissa2 & 0x8000000000000000U) == 0)
                {
                    mantissa2 <<= 1;
                    --exponent2;
                }
                mantissa2 /= 5;
                ++exponent10;
            }
            // TODO: implement math.ldexpf (which presumably handles denormals (i don't))
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = mantissa2;
            var e = (int)((ufu.uintValue >> 23) & 0xFFU) - 127;
            e += exponent2;
            if (e > 128)
                return ParseError.Overflow;
            if (e < -127)
                return ParseError.Underflow;
            ufu.uintValue = (ufu.uintValue & ~(0xFFU<<23)) | ((uint)(e + 127) << 23);
            output = ufu.floatValue;
            return ParseError.None;
        }

        public static void Base2ToBase10(ref ulong mantissa10, ref int exponent10, float input)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            if(ufu.uintValue == 0)
            {
                mantissa10 = 0;
                exponent10 = 0;
                return;
            }
            var mantissa2 = (ufu.uintValue & ((1<<23)-1)) | (1 << 23);
            var exponent2 = (int) (ufu.uintValue >> 23) - 127 - 23;
            mantissa10 = mantissa2;
            exponent10 = exponent2;
            if (exponent2 > 0)
            {
                while (exponent2 > 0)
                {
                    // denormalize mantissa10 as much as you can, to minimize loss when doing /5 below.
                    while (mantissa10 <= UInt64.MaxValue/10)
                    {
                        mantissa10 *= 10;
                        --exponent10;
                    }
                    mantissa10 /= 5;
                    --exponent2;
                }
            }
            if (exponent2 < 0)
            {
                while (exponent2 < 0)
                {
                    // normalize mantissa10 just as much as you need, in order to make the *5 below not overflow.
                    while (mantissa10 > UInt64.MaxValue/5)
                    {
                        mantissa10 /= 10;
                        ++exponent10;
                    }
                    mantissa10 *= 5;
                    ++exponent2;
                }
            }
            // normalize mantissa10
            while (mantissa10 > 9999999U || mantissa10 % 10 == 0)
            {
                mantissa10 = (mantissa10 + (mantissa10 < 100000000U ? 5u : 0u) ) / 10;
                ++exponent10;
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <returns></returns>
        public FormatError Format(char a)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public FormatError Format(char a, char b, char c, char d, char e, char f, char g, char h)
        {
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = a});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = b});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = c});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = d});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = e});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = f});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = g});
            if (Length >= Capacity)
                return FormatError.Overflow;
            Write(ref Length, new Unicode.Rune {value = h});
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source"></param>
        /// <param name="sourceLength"></param>
        /// <param name="decimalExponent"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError FormatScientific(char *source, int sourceLength, int decimalExponent, char decimalSeparator)
        {
            FormatError error;
            if ((error = Format(source[0])) != FormatError.None)
                return error;
            if (sourceLength > 1)
            {
                if ((error = Format(decimalSeparator)) != FormatError.None)
                    return error;
                for (var i = 1; i < sourceLength; ++i)
                {
                    if ((error = Format(source[i])) != FormatError.None)
                        return error;
                }
            }
            if ((error = Format('E')) != FormatError.None)
                return error;
            if (decimalExponent < 0)
            {
                if ((error = Format('-')) != FormatError.None)
                    return error;
                decimalExponent *= -1;
                decimalExponent -= sourceLength - 1;
            }
            else
            {
                if ((error = Format('+')) != FormatError.None)
                    return error;
                decimalExponent += sourceLength - 1;
            }
            var ascii = stackalloc char[2];
            const int decimalDigits = 2;
            for(var i = 0; i < decimalDigits; ++i)
            {
                var decimalDigit = decimalExponent % 10;
                ascii[1 - i] = (char)('0'+decimalDigit);
                decimalExponent /= 10;
            }
            for(var i = 0; i < decimalDigits; ++i)
                if ((error = Format(ascii[i])) != FormatError.None)
                    return error;
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(long input)
        {
            const int maximumDigits = 20;
            var temp = stackalloc byte[maximumDigits];
            int offset = maximumDigits;
            if(input >= 0)
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' + digit);
                    input /= 10;
                } while(input != 0);
            }
            else
            {
                do
                {
                    var digit = (byte)(input % 10);
                    temp[--offset] = (byte)('0' - digit);
                    input /= 10;
                } while(input != 0);
                temp[--offset] = (byte)'-';
            }
            var newLength = maximumDigits - offset;
            if(newLength > Capacity)
                return FormatError.Overflow;
            Length = newLength;
            UnsafeUtility.MemCpy(data, temp + offset, Length);
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public FormatError Format(int input)
        {
            return Format((long)input);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="input"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public FormatError Format(float input, char decimalSeparator)
        {
            UintFloatUnion ufu = new UintFloatUnion();
            ufu.floatValue = input;
            var sign = ufu.uintValue >> 31;
            ufu.uintValue &= ~(1 << 31);
            FormatError error;
            if ((ufu.uintValue & 0x7F800000) == 0x7F800000)
            {
                if(ufu.uintValue == 0x7F800000)
                {
                    if(sign != 0 && ((error = Format('-')) != FormatError.None))
                        return error;
                    return Format( 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y');
                }
                return Format('N', 'a', 'N');
            }
            if (sign != 0 && ufu.uintValue != 0) // C# prints -0 as 0
                if ((error = Format('-')) != FormatError.None)
                    return error;
            ulong decimalMantissa = 0;
            int decimalExponent = 0;
            Base2ToBase10(ref decimalMantissa, ref decimalExponent, ufu.floatValue);
            var backwards = stackalloc char[9];
            int decimalDigits = 0;
            do
            {
                if (decimalDigits >= 9)
                    return FormatError.Overflow;
                var decimalDigit = decimalMantissa % 10;
                backwards[8-decimalDigits++] = (char) ('0' + decimalDigit);
                decimalMantissa /= 10;
            } while (decimalMantissa > 0);
            char *ascii = backwards + 9 - decimalDigits;
            var leadingZeroes = -decimalExponent - decimalDigits + 1;
            if (leadingZeroes > 0)
            {
                if (leadingZeroes > 4)
                    return FormatScientific(ascii, decimalDigits, decimalExponent, decimalSeparator);
                if ((error = Format('0', decimalSeparator)) != FormatError.None)
                    return error;
                --leadingZeroes;
                while (leadingZeroes > 0)
                {
                    if ((error = Format( '0')) != FormatError.None)
                        return error;
                    --leadingZeroes;
                }
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format( ascii[i])) != FormatError.None)
                        return error;
                }
                return FormatError.None;
            }
            var trailingZeroes = decimalExponent;
            if (trailingZeroes > 0)
            {
                if (trailingZeroes > 4)
                    return FormatScientific(  ascii, decimalDigits, decimalExponent, decimalSeparator);
                for (var i = 0; i < decimalDigits; ++i)
                {
                    if ((error = Format( ascii[i])) != FormatError.None)
                        return error;
                }
                while (trailingZeroes > 0)
                {
                    if ((error = Format( '0')) != FormatError.None)
                        return error;
                    --trailingZeroes;
                }
                return FormatError.None;
            }
            var indexOfSeparator = decimalDigits + decimalExponent;
            for (var i = 0; i < decimalDigits; ++i)
            {
                if (i == indexOfSeparator)
                    if ((error = Format(decimalSeparator)) != FormatError.None)
                        return error;
                if ((error = Format( ascii[i])) != FormatError.None)
                    return error;
            }
            return FormatError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c)
        {
            int old = offset;
            if((Read(ref offset).value|32) == a
            && (Read(ref offset).value|32) == b
            && (Read(ref offset).value|32) == c)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="d"></param>
        /// <param name="e"></param>
        /// <param name="f"></param>
        /// <param name="g"></param>
        /// <param name="h"></param>
        /// <returns></returns>
        public bool Found(ref int offset, char a, char b, char c, char d, char e, char f, char g, char h)
        {
            int old = offset;
            if((Read(ref offset).value|32) == a
            && (Read(ref offset).value|32) == b
            && (Read(ref offset).value|32) == c
            && (Read(ref offset).value|32) == d
            && (Read(ref offset).value|32) == e
            && (Read(ref offset).value|32) == f
            && (Read(ref offset).value|32) == g
            && (Read(ref offset).value|32) == h)
                return true;
            offset = old;
            return false;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="output"></param>
        /// <param name="decimalSeparator"></param>
        /// <returns></returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator)
        {
            if(Found(ref offset, 'n', 'a', 'n'))
            {
                UintFloatUnion ufu = new UintFloatUnion();
                ufu.uintValue = 4290772992U;
                output = ufu.floatValue;
                return ParseError.None;
            }
            int sign = 1;
            if (offset < Length)
            {
                if (Peek(offset).value == '+')
                    Read(ref offset);
                else if (Peek(offset).value == '-')
                {
                    sign = -1;
                    Read(ref offset);
                }
            }
            ulong decimalMantissa = 0;
            int significantDigits = 0;
            int digitsAfterDot = 0;
            int mantissaDigits = 0;
            if(Found(ref offset, 'i', 'n', 'f', 'i', 'n', 'i', 't', 'y'))
            {
                output = (sign == 1) ? Single.PositiveInfinity : Single.NegativeInfinity;
                return ParseError.None;
            }
            while (offset < Length && IsDigit(Peek(offset)))
            {
                ++mantissaDigits;
                if (significantDigits < 9)
                {
                    var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                    if (temp > decimalMantissa)
                        ++significantDigits;
                    decimalMantissa = temp;
                }
                else
                    --digitsAfterDot;
                Read(ref offset);
            }
            if (offset < Length && Peek(offset).value == decimalSeparator)
            {
                Read(ref offset);
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++mantissaDigits;
                    if (significantDigits < 9)
                    {
                        var temp = decimalMantissa * 10 + (ulong)(Peek(offset).value - '0');
                        if (temp > decimalMantissa)
                            ++significantDigits;
                        decimalMantissa = temp;
                        ++digitsAfterDot;
                    }
                    Read(ref offset);
                }
            }
            if (mantissaDigits == 0)
                return ParseError.Syntax;
            int decimalExponent = 0;
            int decimalExponentSign = 1;
            if (offset < Length && (Peek(offset).value|32) == 'e')
            {
                Read(ref offset);
                if (offset < Length)
                {
                    if (Peek(offset).value == '+')
                        Read(ref offset);
                    else if (Peek(offset).value == '-')
                    {
                        decimalExponentSign = -1;
                        Read(ref offset);
                    }
                }
                int exponentDigits = 0;
                while (offset < Length && IsDigit(Peek(offset)))
                {
                    ++exponentDigits;
                    decimalExponent = decimalExponent * 10 + (Peek(offset).value - '0');
                    if (decimalExponent > 38)
                        if(decimalExponentSign == 1)
                            return ParseError.Overflow;
                        else
                            return ParseError.Underflow;
                    Read(ref offset);
                }
                if (exponentDigits == 0)
                    return ParseError.Syntax;
            }
            decimalExponent = decimalExponent * decimalExponentSign - digitsAfterDot;
            var error = Base10ToBase2(ref output, decimalMantissa, decimalExponent);
            if (error != ParseError.None)
                return error;
            output *= sign;
            return ParseError.None;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destUTF8MaxLengthInBytes, char *src, int srcLength)
        {
            if(ConversionError.None == Unicode.Utf16ToUtf8(src, srcLength, dest, out destLength, destUTF8MaxLengthInBytes))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out int destLength, int destUTF8MaxLengthInBytes, byte *src, int srcLength)
        {
            destLength = srcLength > destUTF8MaxLengthInBytes ? destUTF8MaxLengthInBytes : srcLength;
            UnsafeUtility.MemCpy(dest, src, destLength);
            return destLength == srcLength ? CopyError.None : CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out int destLength, int destUTF8MaxLengthInBytes, byte *src, int srcLength)
        {
            if(ConversionError.None == Unicode.Utf8ToUtf16(src, srcLength, dest, out destLength, destUTF8MaxLengthInBytes))
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(byte *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Copy(char *dest, out ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest, out var temp, destUTF8MaxLengthInBytes);
            destLength = (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf8(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(byte *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, char *src, ushort srcLength)
        {
            var error = Unicode.Utf16ToUtf8(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="dest"></param>
        /// <param name="destLength"></param>
        /// <param name="destUTF8MaxLengthInBytes"></param>
        /// <param name="src"></param>
        /// <param name="srcLength"></param>
        /// <returns></returns>
        public static CopyError Append(char *dest, ref ushort destLength, ushort destUTF8MaxLengthInBytes, byte *src, ushort srcLength)
        {
            var error = Unicode.Utf8ToUtf16(src, srcLength, dest + destLength, out var temp, destUTF8MaxLengthInBytes - destLength);
            destLength += (ushort)temp;
            if(error == ConversionError.None)
                return CopyError.None;
            return CopyError.Truncation;
        }
    }

    [StructLayout(LayoutKind.Explicit, Size=16)]
    internal struct FixedBytes16
    {
<#
    for(var i = 0; i < 16; ++i)
    {
       var offset = i.ToString("D4");
#>
      [FieldOffset(<#=i#>)] internal byte byte<#=offset#>;
<#
    }
#>
    }

<#
{
    var SIZES = new int[]{32,64,128,512,4096};
    foreach (var BYTES in SIZES) {
      var MAXLENGTH = BYTES - 2;
#>

    [StructLayout(LayoutKind.Explicit, Size=<#=MAXLENGTH#>)]
    internal struct FixedBytes<#=MAXLENGTH#>
    {
<#
      for(var i = 0; i < (MAXLENGTH/16)*16; i += 16)
      {
        var offset = i.ToString("D4");
#>
        [FieldOffset(<#=i#>)] internal FixedBytes16 offset<#=offset#>;
<#
      }
      for(var i = (MAXLENGTH/16)*16; i < MAXLENGTH; ++i)
      {
        var offset = i.ToString("D4");
#>
        [FieldOffset(<#=i#>)] internal byte byte<#=offset#>;
<#
      }
#>
    }

    /// <summary>
    /// An unmanaged string in UTF-8 format that contains its own fixed-size buffer of the given size in bytes.
    /// The string is NOT guaranteed to be null-terminated, though in many cases it may be by accident.
    /// No memory is ever allocated, and no attempt is made to share memory when strings are copied.
    /// Since this structure is not generic and needs no disposing, it can exist inside ECS components,
    /// can be put in a FixedArray, FixedList or FixedHashMap, and can be a data member of unmanaged structs
    /// that are allocated from the unmanaged heap. This string is entirely compatible with Burst compilation.
    ///
    /// The binary layout of this string is guaranteed, for now and all time, to be two bytes of little-endian length,
    /// followed by a contiguous array of bytes with that length, with no padding in between. This is intentionally
    /// identical to FixedList of byte, which is guaranteed to always have the same memory layout.
    ///
    /// Those who need more than 65,535 contiguous items should allocate from the heap, as storing that many things
    /// contiguously in a C# struct is likely to result in much wasted time, as the compiler copies the struct often.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Size=<#=BYTES#>)]
    public struct FixedString<#=BYTES#>
    : INativeList<byte>
    , IComparable<String>
    , IEquatable<String>
<#
    foreach (var OTHERBYTES in SIZES)
    {
        WriteLine("    , IEquatable<FixedString{0}>", OTHERBYTES);
#><#
    }
#>
    {
        internal ushort utf8LengthInBytes;
        internal FixedBytes<#=MAXLENGTH#> bytes;

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckIndexInRange(int index)
        {
            if (index < 0)
                throw new IndexOutOfRangeException($"Index {index} must be positive.");
            if (index >= utf8LengthInBytes)
                throw new IndexOutOfRangeException($"Index {index} is out of range in FixedString<#=BYTES#> of '{utf8LengthInBytes}' Length.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckLengthInRange(int length)
        {
            if (length < 0)
                throw new ArgumentOutOfRangeException($"Length {length} must be positive.");
            if (length > UTF8MaxLengthInBytes)
                throw new ArgumentOutOfRangeException($"Length {length} is out of range in FixedString<#=BYTES#> of '{UTF8MaxLengthInBytes}' Capacity.");
        }

        [Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
        private void CheckCapacityInRange(int capacity)
        {
            if(capacity != Capacity)
                throw new ArgumentOutOfRangeException($"Capacity {capacity} must be {Capacity}.");
        }

        public int Length
        {
            get
            {
                return utf8LengthInBytes;
            }
            set
            {
                CheckLengthInRange(value);
                utf8LengthInBytes = (ushort)value;
            }
        }

        public int Capacity
        {
            get
            {
                return UTF8MaxLengthInBytes;
            }
            set
            {
                CheckCapacityInRange(value);
            }
        }

        public byte this[int index]
        {
            get
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes<#=MAXLENGTH#>* b = &bytes)
                        return ((byte*)b)[index];
                }
            }
            set
            {
                CheckIndexInRange(index);
                unsafe
                {
                    fixed(FixedBytes<#=MAXLENGTH#>* b = &bytes)
                        ((byte*)b)[index] = value;
                }
            }
        }

        public ref byte ElementAt(int index)
        {
            unsafe
            {
                fixed(FixedBytes<#=MAXLENGTH#>* b = &bytes)
                    return ref ((byte*)b)[index];
            }
        }

        /// <summary>
        /// The maximum length of the string, in bytes.
        /// </summary>
        public const int UTF8MaxLengthInBytes = <#=MAXLENGTH#>;

        /// <summary>
        /// The current length of the string, in bytes. As the string is encoded as UTF-8,
        /// each code point may be from 1 to 4 bytes in size. The string is not
        /// null-terminated, though it may sometimes be.
        /// </summary>
        public int UTF8LengthInBytes => utf8LengthInBytes;

        /// <summary>
        /// When it's desirable to manipulate the string as an array of UTF-8 bytes, this property
        /// reinterprets the FixedString<#=BYTES#> as a FixedListByte<#=BYTES#>, which has the same
        /// memory layout.
        /// </summary>
        public ref FixedListByte<#=BYTES#> AsFixedList
        {
            get
            {
                unsafe
                {
                    fixed(FixedString<#=BYTES#>* t = &this)
                        return ref UnsafeUtilityEx.AsRef<FixedListByte<#=BYTES#>>(t);
                }
            }
        }

        /// <summary>
        /// Returns the effective size of this struct in bytes, considering only the bytes that
        /// are actually used to hold data. Since the string may be shorter or longer, the
        /// effective size may be smaller than the UnsafeUtility.SizeOf&lt;FixedString<#=BYTES#>&gt;() size. FixedBytes at the
        /// end of the structure outside of the effective size, may contain any value, but
        /// typically contain the value 0.
        /// </summary>
        /// <returns>The effective size of this struct in bytes.</returns>
        public int EffectiveSizeOf()
        {
            return sizeof(ushort) + utf8LengthInBytes;
        }

        /// <summary>
        /// Parse an integer from this FixedString<#=BYTES#>, at the byte offset indicated from the beginning
        /// of the FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The integer so parsed, if any.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref int output)
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic{data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output);
                }
            }
        }

        /// <summary>
        /// Parse a float from this FixedString<#=BYTES#>, at the byte offset indicated. The resulting float
        /// is intended to be bitwise-identical to the output of System.Single.Parse().
        /// </summary>
        /// <param name="offset">The zero-based byte offset from the beginning of the string.</param>
        /// <param name="output">The float so parsed, if any.</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the parse fails.</returns>
        public ParseError Parse(ref int offset, ref float output, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    return temp.Parse(ref offset, ref output, decimalSeparator);
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString<#=BYTES#> with the UTF-8 representation of a given integer.
        /// </summary>
        /// <param name="input">The integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(int input)
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString<#=BYTES#> with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(long input)
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given integer to the contents of this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="input">The integer to append as UTF-8 to the contents of this FixedString<#=BYTES#></param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(int input)
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given long integer to the contents of this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="input">The long integer to append as UTF-8 to the contents of this FixedString<#=BYTES#></param>
        /// <returns>An error code, if any, in the case that the append fails.</returns>
        public FormatError Append(long input)
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Overwrite the contents of this FixedString<#=BYTES#> with the UTF-8 representation of a given float.
        /// </summary>
        /// <param name="input">The float to write as UTF-8</param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes = (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Append the UTF-8 representation of a given float to the contents of this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="input">The float to append as UTF-8 to the contents of this FixedString<#=BYTES#></param>
        /// <param name="decimalSeparator">The character used to separate the integral part from the fractional part.
        /// In the USA this is a period by default, and in Europe it is a comma by default.</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Append(float input, char decimalSeparator = '.')
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    Generic temp = new Generic {data = b + utf8LengthInBytes, Length = 0, Capacity = UTF8MaxLengthInBytes - utf8LengthInBytes};
                    var error = temp.Format(input, decimalSeparator);
                    utf8LengthInBytes += (ushort)temp.Length;
                    return error;
                }
            }
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> that is a single Unicode.Rune, repeated multiple times.
        /// </summary>
        /// <param name="rune">The Unicode.Rune to repeat</param>
        /// <param name="count">The number of times to repeat the Unicode.Rune</param>
        public FixedString<#=BYTES#>(Unicode.Rune rune, int count)
        {
            utf8LengthInBytes = default;
            bytes = default;
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    int offset = 0;
                    for(var i = 0; i < count; ++i)
                    {
                        var error = Unicode.UcsToUtf8(b, ref offset, UTF8MaxLengthInBytes, rune);
                        if(error != ConversionError.None)
                            throw new ArgumentException($"FixedString32: {error} while constructing from char {rune.value} and count {count}");
                        utf8LengthInBytes = (ushort)offset;
                    }
                }
            }
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> that is a single UCS-2 character, repeated multiple times.
        /// Keep in mind that UCS-2 is incapable of expressing emoji, rare Chinese characters, and various other things.
        /// </summary>
        /// <param name="c">The UCS-2 character to repeat</param>
        /// <param name="count">The number of times to repeat the UCS character</param>
        public FixedString<#=BYTES#>(char c, int count)
        : this(new Unicode.Rune{value=c}, count)
        {
        }

<#
    foreach (var OTHERBYTES in SIZES)
    {
        var TYPENAME = "FixedString" + BYTES;
        var OTHERTYPENAME = "FixedString" + OTHERBYTES;

#>

        /// <summary>
        /// Overwrite the contents of this FixedString<#=BYTES#> with the UTF-8 representation of a given long integer.
        /// </summary>
        /// <param name="input">The long integer to write as UTF-8</param>
        /// <returns>An error code, if any, in the case that the format fails.</returns>
        public FormatError Format(in FixedString<#=OTHERBYTES#> input)
        {
            return (FormatError)CopyFrom(input);
        }

        /// <summary>
        /// Append a FixedString<#=OTHERBYTES#> to the end of this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="source">The <#=OTHERBYTES#> to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendFrom(in FixedString<#=OTHERBYTES#> source)
        {
            fixed(byte* b = &bytes.offset0000.byte0000)
                return source.AppendTo(b, ref utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Append a FixedString<#=OTHERBYTES#> to the end of this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="source">The <#=OTHERBYTES#> to append to the end of this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public CopyError Append(in FixedString<#=OTHERBYTES#> source)
        {
            return AppendFrom(source);
        }

        /// <summary>
        /// Copy a FixedString<#=OTHERBYTES#> onto this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="source">The <#=OTHERBYTES#> to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(in FixedString<#=OTHERBYTES#> source)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return source.CopyTo(b, out utf8LengthInBytes, UTF8MaxLengthInBytes);
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString<#=OTHERBYTES#>,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString<#=OTHERBYTES#> to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the FixedString<#=OTHERBYTES#> was not found.
        /// otherwise, the index of the first occurrence of the FixedString<#=OTHERBYTES#>
        /// </returns>
        public int IndexOf(in FixedString<#=OTHERBYTES#> other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            if(startIndex >= utf8LengthInBytes)
                return -1;
            if(startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if(startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed (byte* a = &bytes.offset0000.byte0000)
                fixed (byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.IndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the last occurrence of a FixedString<#=OTHERBYTES#>,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The FixedString<#=OTHERBYTES#> to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the FixedString<#=OTHERBYTES#> was not found.
        /// otherwise, the index of the first occurrence of the FixedString<#=OTHERBYTES#>
        /// </returns>
        public int LastIndexOf(in FixedString<#=OTHERBYTES#> other, int startIndex = UTF8MaxLengthInBytes-1, int count = UTF8MaxLengthInBytes)
        {
            startIndex -= (count - 1);
            if(startIndex >= utf8LengthInBytes)
                return -1;
            if(startIndex < 0)
            {
                count += startIndex;
                startIndex = 0;
            }
            if(startIndex + count > utf8LengthInBytes)
                count = utf8LengthInBytes - startIndex;
            unsafe
            {
                fixed (byte* a = &bytes.offset0000.byte0000)
                fixed (byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.LastIndexOf(a + startIndex, count, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Search this string for the first occurrence of a FixedString<#=OTHERBYTES#>,
        /// and return whether the FixedString<#=OTHERBYTES#> was found or not.
        /// </summary>
        /// <param name="other">The FixedString<#=OTHERBYTES#> to search for</param>
        /// <returns>
        /// true if the FixedString<#=OTHERBYTES#> was found, and
        /// false if not.
        /// </returns>
        public bool Contains(in FixedString<#=OTHERBYTES#> other)
        {
            return IndexOf(other) != -1;
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a FixedString<#=OTHERBYTES#>,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString<#=OTHERBYTES#> to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool EqualsIn(in FixedString<#=OTHERBYTES#> other)
        {
            unsafe
            {
                fixed (byte* a = &bytes.offset0000.byte0000)
                fixed (byte* b = &other.bytes.offset0000.byte0000)
                {
                    return Generic.Equals(a, utf8LengthInBytes, b, other.utf8LengthInBytes);
                }
            }
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a FixedString<#=OTHERBYTES#>,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The FixedString<#=OTHERBYTES#> to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(FixedString<#=OTHERBYTES#> other)
        {
            return EqualsIn(other);
        }

        /// <summary>
        /// Determines whether a <#=TYPENAME#> and <#=OTHERTYPENAME#> have the same value.
        /// </summary>
        /// <param name="a">The first string to compare for equality</param>
        /// <param name="b">The second string to compare for equality</param>
        /// <returns></returns>
        public static bool operator ==(in <#=TYPENAME#> a, in <#=OTHERTYPENAME#> b)
        {
            return a.EqualsIn(b);
        }

        /// <summary>
        /// Determines whether a <#=TYPENAME#> and <#=OTHERTYPENAME#> have different values.
        /// </summary>
        /// <param name="a">The first string to compare for inequality</param>
        /// <param name="b">The second string to compare for inequality</param>
        /// <returns></returns>
        public static bool operator !=(in <#=TYPENAME#> a, in <#=OTHERTYPENAME#> b)
        {
            return !a.EqualsIn(b);
        }

<#
        if(OTHERBYTES != BYTES)
        {
#>

        /// <summary>
        /// Construct a FixedString<#=BYTES#> from a FixedString<#=OTHERBYTES#>
        /// </summary>
        /// <param name="source">The <#=OTHERBYTES#> to construct this string from</param>
        public FixedString<#=BYTES#>(in FixedString<#=OTHERBYTES#> source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes<#=MAXLENGTH#>{};
            var error = CopyFrom(source);
            if(error != CopyError.None)
                throw new ArgumentException($"FixedString<#=BYTES#>: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of FixedString<#=OTHERBYTES#> to FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="b">The FixedString<#=OTHERBYTES#> object to convert to a FixedString<#=BYTES#></param>
        /// <returns></returns>
        public static implicit operator FixedString<#=BYTES#>(in FixedString<#=OTHERBYTES#> source) => new FixedString<#=BYTES#>(source);

<#
        }
    }
#>

        [ExcludeFromDocs]
        public struct Enumerator
        {
            FixedString<#=BYTES#> target;
            int offset;
            Unicode.Rune current;
            public Enumerator(FixedString<#=BYTES#> other)
            {
                target = other;
                offset = 0;
                current = default;
            }
            public Unicode.Rune Current => current;
            public bool MoveNext()
            {
                if(offset >= target.UTF8LengthInBytes)
                    return false;
                unsafe
                {
                    fixed(byte* b = &target.bytes.offset0000.byte0000)
                        Unicode.Utf8ToUcs(out current, b, ref offset, target.UTF8LengthInBytes);
                }
                return true;
            }
        }

        /// <summary>
        /// Returns an enumerator that iterates through a container.
        /// </summary>
        /// <returns>An IEnumerator object that can be used to iterate through the container.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        /// <summary>
        /// Search this string for the first occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Uniode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching from</param>
        /// <param name="count">The count of bytes to search from the starting index</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int IndexOf(Unicode.Rune other, int startIndex = 0, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return IndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Search this string for the last occurrence of a Unicode.Rune,
        /// and return the index of where it was found, if any.
        /// </summary>
        /// <param name="other">The Unicode.Rune to search for</param>
        /// <param name="startIndex">The byte index to begin searching backwards from</param>
        /// <param name="count">The count of bytes to search from the starting index backward</param>
        /// <returns>
        /// -1 if the Unicode.Rune was not found.
        /// otherwise, the index of the first occurrence of the Unicode.Rune
        /// </returns>
        public int LastIndexOf(Unicode.Rune other, int startIndex = UTF8MaxLengthInBytes-1, int count = UTF8MaxLengthInBytes)
        {
            FixedString32 temp = new FixedString32(other, 1);
            return LastIndexOf(temp, startIndex, count);
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a System.String in terms of lexigraphical order,
        /// and return which of the two strings would come first if sorted.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>
        /// -1 if this FixedString<#=BYTES#> would appear first if sorted,
        ///  0 if they are identical, or
        ///  1 if the other System.String would appear first if sorted.
        /// </returns>
        public int CompareTo(String other)
        {
            return ToString().CompareTo(other);
        }

        /// <summary>
        /// Compare this FixedString<#=BYTES#> with a System.String,
        /// and return whether they contain the same string or not.
        /// </summary>
        /// <param name="other">The System.String to compare with</param>
        /// <returns>true if they are equal, or false if they are not.</returns>
        public bool Equals(String other)
        {
            return ToString().Equals(other);
        }

        /// <summary>
        /// Copy UTF-16 data from a buffer onto this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="s">A pointer to the UTF-16 data to copy</param>
        /// <param name="length">The length, in 16-bit words, of the UTF-16 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(char* s, ushort length)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-8 data from a buffer onto this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="s">A pointer to the UTF-8 data to copy</param>
        /// <param name="length">The length, in 8-bit bytes, of the UTF-8 data to copy</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(byte* s, ushort length)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Copy(b, out utf8LengthInBytes, UTF8MaxLengthInBytes, s, length);
        }

        /// <summary>
        /// Copy UTF-16 data from a System.String onto this FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="source">The System.String to copy onto this string</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyFrom(String source)
        {
            if (string.IsNullOrEmpty(source))
            {
                utf8LengthInBytes = 0;
                return CopyError.None;
            }
            fixed(char *c = source)
                return CopyFrom(c, (ushort)source.Length);
        }

        /// <summary>
        /// Copy this FixedString<#=BYTES#> into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the copy</param>
        /// <param name="length">The length, in bytes, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of bytes that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(byte* d, out ushort length, ushort maxLength)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Copy this FixedString<#=BYTES#> into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data copied to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that will be copied to the destination buffer</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError CopyTo(char* d, out ushort length, ushort maxLength)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Copy(d, out length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString<#=BYTES#> into a buffer of UTF-8 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-8 buffer destination for the append</param>
        /// <param name="length">The length, in bytes, of the data that already exists in the UTF-8 buffer</param>
        /// <param name="maxLength">The maximum number of bytes that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(byte* d, ref ushort length, ushort maxLength)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Append this FixedString<#=BYTES#> into a buffer of UTF-16 data.
        /// </summary>
        /// <param name="d">A pointer to the UTF-16 buffer destination for the copy</param>
        /// <param name="length">The length, in 16-bit units, of the data appended to the destination buffer</param>
        /// <param name="maxLength">The maximum number of 16-bit units that the destination buffer can hold</param>
        /// <returns>An error code, if any, in the case that the operation fails.</returns>
        public unsafe CopyError AppendTo(char* d, ref ushort length, ushort maxLength)
        {
            fixed (byte* b = &bytes.offset0000.byte0000)
                return Generic.Append(d, ref length, maxLength, b, utf8LengthInBytes);
        }

        /// <summary>
        /// Construct a FixedString<#=BYTES#> from a System.String object.
        /// </summary>
        /// <param name="source">The System.String object to construct this FixedString<#=BYTES#> with</param>
        public FixedString<#=BYTES#>(String source)
        {
            utf8LengthInBytes = 0;
            bytes = new FixedBytes<#=MAXLENGTH#>{};
            var error = CopyFrom(source);
            if(error != CopyError.None)
                throw new ArgumentException($"FixedString<#=BYTES#>: {error} while copying \"{source}\"");
        }

        /// <summary>
        /// Enable implicit conversion of System.String to FixedString<#=BYTES#>.
        /// </summary>
        /// <param name="b">The System.String object to convert to a FixedString<#=BYTES#></param>
        /// <returns></returns>
        public static implicit operator FixedString<#=BYTES#>(string b) => new FixedString<#=BYTES#>(b);

        /// <summary>
        /// Convert this FixedString<#=BYTES#> to a System.String.
        /// </summary>
        /// <returns>A System.String with a copy of this FixedString<#=BYTES#></returns>
        public override String ToString()
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.ToString();
                }
            }
        }

        /// <summary>
        /// Compute a hash code of this FixedString<#=BYTES#>: an integer that is likely to be different for
        /// two FixedString<#=BYTES#>, if their contents are different.
        /// </summary>
        /// <returns>A hash code of this FixedString<#=BYTES#></returns>
        public override int GetHashCode()
        {
            unsafe
            {
                fixed (byte* b = &bytes.offset0000.byte0000)
                {
                    return new Generic {data = b, Length = utf8LengthInBytes, Capacity = UTF8MaxLengthInBytes}.GetHashCode();
                }
            }
        }

        /// <summary>
        /// Determines whether a FixedString<#=BYTES#> has the same value as some other object.
        /// </summary>
        /// <param name="obj">The object to compare for equality</param>
        public override bool Equals(object obj)
        {
            if(ReferenceEquals(null, obj)) return false;
            if(obj is String aString) return Equals(aString);
<#
    foreach(var OTHERBYTES in SIZES)
    {
        var OTHERTYPENAME = "FixedString" + OTHERBYTES;
        WriteLine("            if(obj is {0} a{0}) return Equals(a{0});", OTHERTYPENAME);
    }
#>
            return false;
        }
    }
<#}}#>
}
