<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ output extension=".gen.cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Samples/Packages/com.unity.entities/Unity.Entities/UnsafeList.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;

namespace Unity.Entities
{
<#
{
    foreach (var (type, typeName) in new[] {
        ( "int",  "Int"  ),
        ( "uint", "Uint" ),
    }) {
#>
    [DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}")]
    [DebuggerTypeProxy(typeof(Unsafe<#=typeName#>ListDebugView))]
    internal unsafe struct Unsafe<#=typeName#>List : IDisposable
    {
        [NativeDisableUnsafePtrRestriction]
        public readonly <#=type#>* Ptr;
        public readonly int Length;
        public readonly int Capacity;
        public readonly AllocatorManager.AllocatorHandle Allocator;

        public unsafe Unsafe<#=typeName#>List(int initialCapacity, AllocatorManager.AllocatorHandle allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { Ptr = null; Length = 0; Capacity = 0; Allocator = AllocatorManager.None; this.ListData() = new UnsafeList(UnsafeUtility.SizeOf<<#=type#>>(), UnsafeUtility.AlignOf<<#=type#>>(), initialCapacity, allocator, options); }
        public unsafe Unsafe<#=typeName#>List(int initialCapacity, Allocator allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { Ptr = null; Length = 0; Capacity = 0; Allocator = AllocatorManager.None; this.ListData() = new UnsafeList(UnsafeUtility.SizeOf<<#=type#>>(), UnsafeUtility.AlignOf<<#=type#>>(), initialCapacity, allocator, options); }
        public bool IsCreated => Ptr != null;
        public void Dispose() { this.ListData().Dispose(); }
        public JobHandle Dispose(JobHandle inputDeps) { return this.ListData().Dispose(inputDeps); }
        public void Clear() { this.ListData().Clear(); }
        public void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { this.ListData().Resize<<#=type#>>(length, options); }
        public void SetCapacity(int capacity) { this.ListData().SetCapacity<<#=type#>>(capacity); }
        public void TrimExcess() { this.ListData().TrimExcess<<#=type#>>(); }
        public int IndexOf(<#=type#> value) { return this.ListData().IndexOf(value); }
        public bool Contains(<#=type#> value) { return this.ListData().Contains(value); }
        public void AddNoResize(<#=type#> value) { this.ListData().AddNoResize(value); }
        public void AddRangeNoResize(void* ptr, int length) { this.ListData().AddRangeNoResize<<#=type#>>(ptr, length); }
        public void AddRangeNoResize(Unsafe<#=typeName#>List src) { this.ListData().AddRangeNoResize<<#=type#>>(src.ListData()); }
        public void Add(<#=type#> value) { this.ListData().Add(value); }
        public void AddRange(Unsafe<#=typeName#>List src) { this.ListData().AddRange<<#=type#>>(src.ListData()); }
        public void RemoveAtSwapBack(int index) { this.ListData().RemoveAtSwapBack<<#=type#>>(index); }

        public ParallelReader AsParallelReader() { return new ParallelReader(Ptr, Length); }

        public unsafe struct ParallelReader
        {
            [NativeDisableUnsafePtrRestriction]
            public readonly <#=type#>* Ptr;
            public readonly int Length;

            public ParallelReader(<#=type#>* ptr, int length) { Ptr = ptr; Length = length; }
            public int IndexOf(<#=type#> value) { for (int i = 0; i < Length; ++i) { if (Ptr[i] == value) { return i; } } return -1; }
            public bool Contains(<#=type#> value) { return IndexOf(value) != -1; }
        }

        public ParallelWriter AsParallelWriter() { return new ParallelWriter((UnsafeList*)UnsafeUtility.AddressOf(ref this)); }

        public unsafe struct ParallelWriter
        {
            public UnsafeList.ParallelWriter Writer;

            public unsafe ParallelWriter(UnsafeList* listData) { Writer = listData->AsParallelWriter(); }

            public void AddNoResize(<#=type#> value) { Writer.AddNoResize(value); }
            public void AddRangeNoResize(void* ptr, int length) { Writer.AddRangeNoResize<<#=type#>>(ptr, length); }
            public void AddRangeNoResize(Unsafe<#=typeName#>List list) { Writer.AddRangeNoResize<<#=type#>>(Unsafe<#=typeName#>ListExtensions.ListData(ref list)); }
        }
    }

    internal static class Unsafe<#=typeName#>ListExtensions
    {
        public static ref UnsafeList ListData(ref this Unsafe<#=typeName#>List from) => ref UnsafeUtilityEx.As<Unsafe<#=typeName#>List, UnsafeList>(ref from);
    }

    sealed class Unsafe<#=typeName#>ListDebugView
    {
        private Unsafe<#=typeName#>List m_ListData;

        public Unsafe<#=typeName#>ListDebugView(Unsafe<#=typeName#>List listData)
        {
            m_ListData = listData;
        }

        public unsafe <#=type#>[] Items
        {
            get
            {
                var result = new <#=type#>[m_ListData.Length];
                var ptr    = m_ListData.Ptr;

                for (int i = 0, num = result.Length; i < num; ++i)
                {
                    result[i] = ptr[i];
                }

                return result;
            }
        }
    }

<#}}#>
<#
{
    foreach (var (type, typeName, typeDebugView) in new[] {
        ( "Chunk",     "Chunk",     "ArchetypeChunk"  ),
        ( "Archetype", "Archetype", "EntityArchetype" ),
        ( "EntityQueryData", "EntityQueryData", "EntityQueryData*" ),
    }) {
#>
    [DebuggerDisplay("Length = {Length}, Capacity = {Capacity}, IsCreated = {IsCreated}")]
    [DebuggerTypeProxy(typeof(Unsafe<#=typeName#>PtrListDebugView))]
    internal unsafe struct Unsafe<#=typeName#>PtrList : IDisposable
    {
        [NativeDisableUnsafePtrRestriction]
        public readonly <#=type#>** Ptr;
        public readonly int Length;
        public readonly int Capacity;
        public readonly AllocatorManager.AllocatorHandle Allocator;

        public unsafe Unsafe<#=typeName#>PtrList(<#=type#>** ptr, int length) { Ptr = null; Length = 0; Capacity = 0; Allocator = AllocatorManager.Invalid; this.ListData() = new UnsafePtrList((void**)ptr, length); }
        public unsafe Unsafe<#=typeName#>PtrList(int initialCapacity, Allocator allocator, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { Ptr = null; Length = 0; Capacity = 0; Allocator = AllocatorManager.None; this.ListData() = new UnsafePtrList(initialCapacity, allocator, options); }
        public bool IsCreated => Ptr != null;
        public void Dispose() { this.ListData().Dispose(); }
        public JobHandle Dispose(JobHandle inputDeps) { return this.ListData().Dispose(inputDeps); }
        public void Clear() { this.ListData().Clear(); }
        public void Resize(int length, NativeArrayOptions options = NativeArrayOptions.UninitializedMemory) { this.ListData().Resize(length, options); }
        public void SetCapacity(int capacity) { this.ListData().SetCapacity(capacity); }
        public void TrimExcess() { this.ListData().TrimExcess(); }
        public int IndexOf(<#=type#>* value) { return this.ListData().IndexOf(value); }
        public bool Contains(<#=type#>* value) { return this.ListData().Contains(value); }
        public void Add(<#=type#>* value) { this.ListData().Add(value); }
        public void AddRange(Unsafe<#=typeName#>PtrList src) { this.ListData().AddRange(src.ListData()); }
        public void RemoveAtSwapBack(int index) { this.ListData().RemoveAtSwapBack(index); }

        public ParallelReader AsParallelReader() { return new ParallelReader(Ptr, Length); }

        public unsafe struct ParallelReader
        {
            [NativeDisableUnsafePtrRestriction]
            public readonly <#=type#>** Ptr;
            public readonly int Length;

            public ParallelReader(<#=type#>** ptr, int length) { Ptr = ptr; Length = length; }
            public int IndexOf(<#=type#>* value) { for (int i = 0; i < Length; ++i) { if (Ptr[i] == value) { return i; } } return -1; }
            public bool Contains(<#=type#>* value) { return IndexOf(value) != -1; }
        }

        public ParallelWriter AsParallelWriter() { return new ParallelWriter((UnsafePtrList*)UnsafeUtility.AddressOf(ref this)); }

        public unsafe struct ParallelWriter
        {
            public UnsafePtrList.ParallelWriter Writer;

            public unsafe ParallelWriter(UnsafePtrList* listData) { Writer = listData->AsParallelWriter(); }

            public void AddNoResize(<#=type#>* value) { Writer.AddNoResize(value); }
            public void AddRangeNoResize(void** ptr, int length) { Writer.AddRangeNoResize(ptr, length); }
            public void AddRangeNoResize(Unsafe<#=typeName#>PtrList list) { Writer.AddRangeNoResize((void**)list.Ptr, list.Length); }
        }
    }

    internal static class Unsafe<#=typeName#>PtrListExtensions
    {
        public static ref UnsafePtrList ListData(ref this Unsafe<#=typeName#>PtrList from) => ref UnsafeUtilityEx.As<Unsafe<#=typeName#>PtrList, UnsafePtrList>(ref from);
    }

    sealed class Unsafe<#=typeName#>PtrListDebugView
    {
        private Unsafe<#=typeName#>PtrList m_ListData;

        public Unsafe<#=typeName#>PtrListDebugView(Unsafe<#=typeName#>PtrList listData)
        {
            m_ListData = listData;
        }

        public unsafe <#=typeDebugView#>[] Items
        {
            get
            {
                var result = new <#=typeDebugView#>[m_ListData.Length];
                var ptr    = m_ListData.Ptr;

                for (int i = 0, num = result.Length; i < num; ++i)
                {
                    result[i] = *(<#=typeDebugView#>*)ptr[i];
                }

                return result;
            }
        }
    }
<#}}#>
}
